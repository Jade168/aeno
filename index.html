<!DOCTYPE html>
<html lang="zh-HK">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>AENO V3 - æ–‡æ˜å¸åœ‹å®Œæ•´ç‰ˆï¼ˆé›¢ç·šå¯ç©ï¼‰</title>
<style>
  :root{
    --card: rgba(255,255,255,0.92);
    --line: rgba(0,0,0,0.10);
    --shadow: 0 14px 30px rgba(0,0,0,0.18);
    --txt: #0f172a;
    --muted: #64748b;
  }
  *{box-sizing:border-box;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans HK","PingFang HK","Microsoft JhengHei",sans-serif;}
  body{
    margin:0;
    overflow:hidden;
    background:linear-gradient(180deg,#bfdbfe,#f0f9ff);
    color:var(--txt);
    user-select:none;
    -webkit-user-select:none;
    touch-action:none;
  }
  #app{width:100vw;height:100vh;position:relative;}
  canvas{position:absolute;inset:0;width:100%;height:100%;}

  .topbar{
    position:absolute;top:10px;left:10px;right:10px;height:58px;
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-radius:20px;background:var(--card);
    border:1px solid var(--line);box-shadow:var(--shadow);
    backdrop-filter: blur(10px); z-index:50;
  }
  .brand{display:flex;align-items:center;gap:10px;}
  .logo{
    width:40px;height:40px;border-radius:16px;
    background:linear-gradient(135deg,#60a5fa,#22c55e);
    display:flex;align-items:center;justify-content:center;
    font-weight:900;color:white;box-shadow:0 10px 18px rgba(0,0,0,0.14);
  }
  .title{display:flex;flex-direction:column;line-height:1.1;}
  .title b{font-size:14px;}
  .title span{font-size:11px;color:var(--muted);font-weight:800;}

  .btnRow{display:flex;gap:8px;align-items:center;}
  .btn{
    border:none;cursor:pointer;font-weight:900;font-size:12px;
    padding:9px 12px;border-radius:16px;color:white;
    box-shadow:0 10px 18px rgba(0,0,0,0.14);
    transition:transform .12s ease;
  }
  .btn:active{transform:scale(0.96);}
  .b1{background:linear-gradient(135deg,#38bdf8,#2563eb);}
  .b2{background:linear-gradient(135deg,#22c55e,#16a34a);}
  .b3{background:linear-gradient(135deg,#fb923c,#f97316);}
  .b4{background:linear-gradient(135deg,#f472b6,#db2777);}
  .b5{background:linear-gradient(135deg,#a78bfa,#7c3aed);}

  .panel{
    position:absolute;background:var(--card);
    border:1px solid var(--line);box-shadow:var(--shadow);
    border-radius:22px;padding:12px;
    backdrop-filter: blur(10px); z-index:60;
  }
  .panelHeader{
    display:flex;align-items:center;justify-content:space-between;
    margin-bottom:10px;gap:10px;
  }
  .panelHeader b{font-size:14px;}
  .panelHeader span{font-size:11px;color:var(--muted);font-weight:800;}
  .collapseBtn{
    border:none;background:rgba(0,0,0,0.05);
    padding:6px 10px;border-radius:14px;
    font-weight:900;cursor:pointer;
  }

  #resPanel{top:78px;left:10px;width:210px;}
  .resRow{
    display:flex;justify-content:space-between;align-items:center;
    padding:6px 8px;border-radius:14px;background:rgba(0,0,0,0.03);
    margin-bottom:6px;font-size:12px;font-weight:900;
  }
  .resRow span:first-child{color:var(--muted);font-weight:900;}

  #menuPanel{top:78px;right:10px;width:240px;}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:8px;}
  .menuItem{
    border:none;border-radius:18px;padding:10px;
    font-weight:900;font-size:12px;color:white;
    cursor:pointer;box-shadow:0 10px 16px rgba(0,0,0,0.12);
    transition:transform .12s ease;
  }
  .menuItem:active{transform:scale(0.96);}
  .m1{background:linear-gradient(135deg,#60a5fa,#2563eb);}
  .m2{background:linear-gradient(135deg,#22c55e,#16a34a);}
  .m3{background:linear-gradient(135deg,#fb923c,#f97316);}
  .m4{background:linear-gradient(135deg,#fbbf24,#f59e0b);}
  .m5{background:linear-gradient(135deg,#a78bfa,#7c3aed);}
  .m6{background:linear-gradient(135deg,#f472b6,#db2777);}

  /* AI Assistant bubble on map */
  #aiBubble{
    position:absolute;
    width:78px;height:78px;
    border-radius:28px;
    background:linear-gradient(135deg,#fbbf24,#fb7185);
    display:flex;align-items:center;justify-content:center;
    font-size:36px;
    box-shadow:0 16px 26px rgba(0,0,0,0.22);
    z-index:55;
    border:2px solid rgba(255,255,255,0.7);
    cursor:pointer;
    transform:translate(-50%,-70%);
  }
  #aiTag{
    position:absolute;
    transform:translate(-50%,-20%);
    background:rgba(0,0,0,0.75);
    color:white;
    padding:6px 10px;
    border-radius:14px;
    font-size:11px;
    font-weight:900;
    z-index:56;
    pointer-events:none;
  }

  /* Chat panel */
  #chatPanel{
    bottom:10px;left:10px;right:10px;height:240px;
    display:flex;flex-direction:column;
  }
  #chatLog{
    flex:1;overflow:auto;
    background:rgba(0,0,0,0.03);
    border-radius:18px;
    padding:8px;
  }
  .msg{
    padding:8px 10px;border-radius:16px;
    margin-bottom:8px;max-width:92%;
    box-shadow:0 6px 14px rgba(0,0,0,0.06);
    font-size:12px;font-weight:800;line-height:1.3;
  }
  .ai{background:white;border:1px solid rgba(0,0,0,0.06);}
  .user{background:linear-gradient(135deg,#38bdf8,#2563eb);color:white;margin-left:auto;}

  .chatInput{display:flex;gap:8px;margin-top:10px;}
  .chatInput input{
    flex:1;border:none;outline:none;
    border-radius:18px;padding:12px;
    border:1px solid rgba(0,0,0,0.08);
    font-weight:900;font-size:13px;
  }
  .chatInput button{
    border:none;border-radius:18px;
    padding:10px 14px;cursor:pointer;
    font-weight:900;color:white;
    background:linear-gradient(135deg,#22c55e,#16a34a);
    box-shadow:0 10px 18px rgba(0,0,0,0.12);
  }

  /* floating reopen */
  .floatingBtn{
    position:absolute;z-index:120;
    width:54px;height:54px;border-radius:22px;
    border:none;cursor:pointer;
    box-shadow:0 14px 24px rgba(0,0,0,0.22);
    font-size:20px;font-weight:900;color:white;
    display:none;
  }
  #openRes{top:84px;left:10px;background:linear-gradient(135deg,#22c55e,#16a34a);}
  #openMenu{top:84px;right:10px;background:linear-gradient(135deg,#fb923c,#f97316);}
  #openChat{bottom:10px;right:10px;background:linear-gradient(135deg,#f472b6,#db2777);}

  /* toast */
  #toast{
    position:absolute;left:50%;
    transform:translateX(-50%);
    bottom:270px;
    background:rgba(0,0,0,0.78);
    color:white;
    padding:10px 14px;
    border-radius:18px;
    font-weight:900;
    font-size:12px;
    display:none;
    z-index:200;
  }

  /* Beast tide warning */
  #warning{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    top:76px;
    background:linear-gradient(135deg,#ef4444,#b91c1c);
    color:white;
    padding:10px 14px;
    border-radius:18px;
    font-weight:900;
    font-size:12px;
    box-shadow:0 14px 26px rgba(0,0,0,0.18);
    display:none;
    z-index:200;
  }
</style>
</head>

<body>
<div id="app">
  <canvas id="cv"></canvas>

  <div class="topbar">
    <div class="brand">
      <div class="logo">A</div>
      <div class="title">
        <b>AENO V3 æ–‡æ˜å¸åœ‹</b>
        <span id="timeText">è¼‰å…¥ä¸­...</span>
      </div>
    </div>
    <div class="btnRow">
      <button class="btn b1" id="btnCenter">ä¸­å¿ƒ</button>
      <button class="btn b2" id="btnZoomIn">ï¼‹</button>
      <button class="btn b3" id="btnZoomOut">ï¼</button>
      <button class="btn b5" id="btnSave">å­˜æª”</button>
    </div>
  </div>

  <div class="panel" id="resPanel">
    <div class="panelHeader">
      <div>
        <b>è³‡æºåº«</b><br><span>åœ°å½¢ç”¢å‡º</span>
      </div>
      <button class="collapseBtn" id="collapseRes">æ”¶èµ·</button>
    </div>
    <div id="resList"></div>
  </div>

  <div class="panel" id="menuPanel">
    <div class="panelHeader">
      <div>
        <b>åŠŸèƒ½è¡¨</b><br><span>æ–‡æ˜å¸åœ‹ç©æ³•</span>
      </div>
      <button class="collapseBtn" id="collapseMenu">æ”¶èµ·</button>
    </div>

    <div class="grid">
      <button class="menuItem m1" id="btnFarm">è¾²ç”°</button>
      <button class="menuItem m2" id="btnMine">ç¤¦å ´</button>
      <button class="menuItem m3" id="btnFactory">å·¥å» </button>
      <button class="menuItem m4" id="btnWall">åŸç‰†</button>
      <button class="menuItem m5" id="btnExpand">æ“´åœ°</button>
      <button class="menuItem m6" id="btnRobot">æ©Ÿæ¢°äºº</button>
    </div>
  </div>

  <!-- AI assistant on map -->
  <div id="aiBubble">ğŸ¦Š</div>
  <div id="aiTag">Vulpes AI</div>

  <!-- Chat -->
  <div class="panel" id="chatPanel">
    <div class="panelHeader">
      <div>
        <b>AI åŠ©æ‰‹å°è©±</b><br><span id="aiState">å·¡é‚ä¸­ Â· è‡ªå‹•ç®¡ç†</span>
      </div>
      <button class="collapseBtn" id="collapseChat">æ”¶èµ·</button>
    </div>
    <div id="chatLog"></div>
    <div class="chatInput">
      <input id="chatText" placeholder="è¼¸å…¥ï¼šæ”¶è³‡æº / å»ºè¾²ç”° / å»ºç¤¦å ´ / å»ºå·¥å»  / å‡ç´š / é˜²å®ˆ / ç¸æ½®"/>
      <button id="sendChat">é€å‡º</button>
    </div>
  </div>

  <!-- reopen buttons -->
  <button class="floatingBtn" id="openRes">ğŸ“¦</button>
  <button class="floatingBtn" id="openMenu">ğŸ› ï¸</button>
  <button class="floatingBtn" id="openChat">ğŸ¦Š</button>

  <div id="toast"></div>
  <div id="warning">âš ï¸ ç¸æ½®ä¾†è¥²ï¼åŸç‰†é˜²å®ˆä¸­...</div>
</div>

<script>
/* =========================================================
   AENO V3 Civilization Edition (Single File)
   - Procedural terrain: mountain/river/forest/plains
   - Mines & veins (stone/iron/gold/crystal)
   - Farms, factories, walls
   - Wild animals roaming
   - Beast tide event
   - Big map + expand territory
   - Drag + mousewheel zoom + pinch zoom
   - AI assistant walking on map (not bottom)
   - Offline save/load (localStorage)
   - Online forced update record check (lightweight)
   ========================================================= */

const APP_VERSION = "AENO-V3-CIV-2026-02-14-01"; // å¼·åˆ¶æ›´æ–°ç‰ˆæœ¬è™Ÿ
const UPDATE_URL = "update.json"; // ä½ æ—¥å¾Œå¯åŠ ä¸€å€‹ update.json æª”æ¡ˆåšç‰ˆæœ¬æ§åˆ¶

const cv = document.getElementById("cv");
const ctx = cv.getContext("2d");

function resize(){
  cv.width = innerWidth * devicePixelRatio;
  cv.height = innerHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
addEventListener("resize", resize);
resize();

/* ===== UI ===== */
const toast = document.getElementById("toast");
const warning = document.getElementById("warning");
function showToast(t){
  toast.innerText = t;
  toast.style.display="block";
  clearTimeout(showToast._t);
  showToast._t=setTimeout(()=>toast.style.display="none",1400);
}

/* ===== Random ===== */
function rnd(seed){
  // deterministic random (LCG)
  seed = (seed * 1664525 + 1013904223) >>> 0;
  return [seed, seed / 4294967296];
}

/* ===== Game State ===== */
const game = {
  map: { rows: 70, cols: 70 },
  tile: { size: 38, isoAngle: Math.PI/6 },
  cam: { x:0, y:0, zoom: 1.0 },
  time: { year: 1000, day: 1 },
  territory: { radius: 6 },
  resources: {
    AENO: 200,
    Food: 80,
    Wood: 60,
    Stone: 40,
    Iron: 0,
    Gold: 0,
    Crystal: 1,
    Energy: 0,
    Robots: 0,
    Population: 12
  },
  mapData: [],
  buildings: [],
  animals: [],
  beasts: [],
  selectedId: null,
  lastTick: performance.now(),
  lastAI: performance.now(),
  lastBeast: performance.now(),
  dragging:false,
  dragStart:{x:0,y:0},
  camStart:{x:0,y:0},
  pinch:false,
  pinchDist:0,
  pinchZoom:1,
  clouds: [],
  ai: {
    x: 0, y: 0,
    tx: 0, ty: 0,
    mood: "å·¡é‚ä¸­",
    lastMove: performance.now()
  },
  online: { lastCheck: 0, updateAvailable: false }
};

/* ===== Tile Types ===== */
const TILE = {
  WATER: "water",
  RIVER: "river",
  GRASS: "grass",
  FOREST: "forest",
  HILL: "hill",
  MOUNTAIN: "mountain",
  SAND: "sand"
};

const VEIN = {
  NONE: "",
  STONE: "stone",
  IRON: "iron",
  GOLD: "gold",
  CRYSTAL: "crystal"
};

const BLD = {
  FARM: "è¾²ç”°",
  MINE: "ç¤¦å ´",
  FACTORY: "å·¥å» ",
  WALL: "åŸç‰†"
};

/* ===== Colors ===== */
const C = {
  skyTop:"#bfdbfe",
  skyBot:"#f0f9ff",
  water1:"#60a5fa",
  water2:"#3b82f6",
  river:"#38bdf8",
  grass1:"#dcfce7",
  grass2:"#bbf7d0",
  forest1:"#4ade80",
  forest2:"#16a34a",
  hill1:"#fde68a",
  hill2:"#fbbf24",
  mountain1:"#cbd5e1",
  mountain2:"#64748b",
  sand1:"#fef3c7",
  sand2:"#fde68a",
  border:"rgba(0,0,0,0.06)",
  shadow:"rgba(0,0,0,0.20)"
};

/* ===== Screen <-> Iso ===== */
function gridToScreen(r,c){
  const s = game.tile.size * game.cam.zoom;
  const ax = Math.cos(game.tile.isoAngle) * s;
  const ay = Math.sin(game.tile.isoAngle) * s;
  const x = (c - r) * ax + (innerWidth/2) + game.cam.x;
  const y = (c + r) * ay + 160 + game.cam.y;
  return {x,y,ax,ay};
}

function insideTerritory(r,c){
  const cr = Math.floor(game.map.rows/2);
  const cc = Math.floor(game.map.cols/2);
  const d = Math.abs(r-cr) + Math.abs(c-cc);
  return d <= game.territory.radius;
}

/* ===== Generate Terrain ===== */
function genWorld(seedBase=123456){
  game.mapData = [];
  let seed = seedBase;

  // base noise
  const height = [];
  for(let r=0;r<game.map.rows;r++){
    height[r]=[];
    for(let c=0;c<game.map.cols;c++){
      let v = 0;
      // multi-octave pseudo noise
      for(let o=1;o<=4;o++){
        [seed, rr] = rnd(seed + (r*92821) + (c*68917) + o*777);
        v += rr * (1/o);
      }
      height[r][c]=v;
    }
  }

  // normalize
  let min=999, max=-999;
  for(let r=0;r<game.map.rows;r++){
    for(let c=0;c<game.map.cols;c++){
      min=Math.min(min,height[r][c]);
      max=Math.max(max,height[r][c]);
    }
  }
  for(let r=0;r<game.map.rows;r++){
    for(let c=0;c<game.map.cols;c++){
      height[r][c]=(height[r][c]-min)/(max-min);
    }
  }

  // create river path from high to low
  let riverStart = {r:0,c:0, best:0};
  for(let r=0;r<game.map.rows;r++){
    for(let c=0;c<game.map.cols;c++){
      if(height[r][c]>riverStart.best){
        riverStart={r,c,best:height[r][c]};
      }
    }
  }
  let riverCells = new Set();
  let rr=riverStart.r, cc=riverStart.c;
  for(let i=0;i<300;i++){
    riverCells.add(rr+","+cc);
    // step to lowest neighbor
    let bestN = {r:rr,c:cc,v:height[rr][cc]};
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dr,dc] of dirs){
      const nr=rr+dr,nc=cc+dc;
      if(nr<0||nc<0||nr>=game.map.rows||nc>=game.map.cols) continue;
      if(height[nr][nc] < bestN.v){
        bestN={r:nr,c:nc,v:height[nr][nc]};
      }
    }
    if(bestN.r===rr && bestN.c===cc) break;
    rr=bestN.r; cc=bestN.c;
    if(height[rr][cc]<0.18) break;
  }

  // fill map tiles
  for(let r=0;r<game.map.rows;r++){
    game.mapData[r]=[];
    for(let c=0;c<game.map.cols;c++){
      const h = height[r][c];
      let type = TILE.GRASS;

      if(h<0.18) type = TILE.WATER;
      else if(h<0.22) type = TILE.SAND;
      else if(h<0.55) type = TILE.GRASS;
      else if(h<0.70) type = TILE.FOREST;
      else if(h<0.83) type = TILE.HILL;
      else type = TILE.MOUNTAIN;

      if(riverCells.has(r+","+c) && type!==TILE.WATER){
        type = TILE.RIVER;
      }

      // veins
      let vein = VEIN.NONE;
      if(type===TILE.HILL || type===TILE.MOUNTAIN){
        [seed, rv] = rnd(seed + r*991 + c*771);
        if(rv<0.10) vein = VEIN.STONE;
        else if(rv<0.16) vein = VEIN.IRON;
        else if(rv<0.19) vein = VEIN.GOLD;
        else if(rv<0.205) vein = VEIN.CRYSTAL;
      }

      game.mapData[r][c] = {
        type,
        vein,
        explored: insideTerritory(r,c),
        fertility: (type===TILE.GRASS || type===TILE.RIVER) ? (0.5 + Math.random()*0.5) : 0.15
      };
    }
  }

  // spawn animals
  game.animals=[];
  for(let i=0;i<20;i++){
    [seed, rv] = rnd(seed + i*9999);
    const r = Math.floor(rv*game.map.rows);
    [seed, rv2] = rnd(seed + i*3333);
    const c = Math.floor(rv2*game.map.cols);

    if(game.mapData[r][c].type===TILE.WATER) continue;

    game.animals.push({
      r,c,
      kind: (Math.random()<0.5)?"ğŸ‡":"ğŸ¦Œ",
      t: performance.now() + Math.random()*2000
    });
  }

  // initial clouds
  game.clouds=[];
  for(let i=0;i<7;i++){
    game.clouds.push({
      x: Math.random()*innerWidth,
      y: 60 + Math.random()*200,
      s: 22 + Math.random()*28,
      sp: 0.12 + Math.random()*0.22,
      a: 0.55 + Math.random()*0.25
    });
  }

  // AI assistant initial position near center
  const cr = Math.floor(game.map.rows/2);
  const cc2 = Math.floor(game.map.cols/2);
  game.ai.x = cr;
  game.ai.y = cc2;
  game.ai.tx = cr+1;
  game.ai.ty = cc2+1;

  showToast("ğŸŒ ä¸–ç•Œç”Ÿæˆå®Œæˆ");
}

/* ===== Buildings ===== */
function addBuilding(type){
  // place on selected tile or near center
  let target = null;

  if(game._placingTile){
    target = game._placingTile;
  }else{
    target = {r: Math.floor(game.map.rows/2), c: Math.floor(game.map.cols/2)};
  }

  const r = target.r, c = target.c;

  if(!insideTerritory(r,c)){
    showToast("âŒ å¿…é ˆå…ˆæ“´å¼µé ˜åœŸ");
    aiSay("å‘¢æ ¼å””å–ºä½ é ˜åœŸå…§ï¼Œè¦å…ˆæ“´åœ°ã€‚");
    return;
  }

  const tile = game.mapData[r][c];
  if(tile.type===TILE.WATER){
    showToast("âŒ æ°´ä¸Šä¸èƒ½å»ºé€ ");
    return;
  }

  const occupied = game.buildings.some(b=>b.r===r && b.c===c);
  if(occupied){
    showToast("âŒ æ­¤æ ¼å·²æœ‰å»ºç¯‰");
    return;
  }

  // costs
  const cost = {
    [BLD.FARM]: {Wood:12, Stone:4},
    [BLD.MINE]: {Wood:10, Stone:12},
    [BLD.FACTORY]: {Wood:18, Stone:18, Iron:6},
    [BLD.WALL]: {Stone:14}
  }[type];

  for(const k in cost){
    if(game.resources[k] < cost[k]){
      showToast("âŒ è³‡æºä¸è¶³");
      aiSay("è³‡æºå””å¤ ï¼Œå«æˆ‘æ”¶é›†æˆ–è€…å…ˆå»ºè¾²ç”°/ç¤¦å ´ã€‚");
      return;
    }
  }
  for(const k in cost){
    game.resources[k]-=cost[k];
  }

  const id = crypto.randomUUID();
  game.buildings.push({
    id, type,
    r,c,
    level:1,
    hp: 100,
    bounce:1
  });

  showToast("âœ… å»ºç¯‰å®Œæˆï¼š" + type);
  aiSay(`å®Œæˆï¼æˆ‘å·²å»ºé€ ã€Œ${type}ã€ã€‚`);

  game._placingTile = null;
}

/* ===== Resource Production ===== */
function produceTick(){
  // base consumption by population
  game.resources.Food -= (game.resources.Population * 0.08);
  if(game.resources.Food < 0) game.resources.Food = 0;

  // forests produce wood slowly (only explored)
  for(let r=0;r<game.map.rows;r++){
    for(let c=0;c<game.map.cols;c++){
      if(!insideTerritory(r,c)) continue;
      const t = game.mapData[r][c].type;
      if(t===TILE.FOREST) game.resources.Wood += 0.05;
      if(t===TILE.GRASS) game.resources.Food += 0.02;
      if(t===TILE.RIVER) game.resources.Food += 0.05;
    }
  }

  // buildings
  for(const b of game.buildings){
    if(b.type===BLD.FARM){
      // farm better near river
      const t = game.mapData[b.r][b.c].type;
      const bonus = (t===TILE.RIVER) ? 1.6 : 1.0;
      game.resources.Food += 1.1 * b.level * bonus;
    }

    if(b.type===BLD.MINE){
      const v = game.mapData[b.r][b.c].vein;
      if(v===VEIN.STONE) game.resources.Stone += 0.9 * b.level;
      else if(v===VEIN.IRON) game.resources.Iron += 0.5 * b.level;
      else if(v===VEIN.GOLD) game.resources.Gold += 0.22 * b.level;
      else if(v===VEIN.CRYSTAL) game.resources.Crystal += 0.12 * b.level;
      else game.resources.Stone += 0.3 * b.level;
    }

    if(b.type===BLD.FACTORY){
      // factory consumes iron+stone and produces robots+energy
      if(game.resources.Iron >= 0.5 && game.resources.Stone >= 0.5){
        game.resources.Iron -= 0.5;
        game.resources.Stone -= 0.5;
        game.resources.Energy += 0.7 * b.level;

        if(Math.random()<0.15){
          game.resources.Robots += 1;
          aiSay("å·¥å» å®Œæˆä¸€å€‹æ–°æ©Ÿæ¢°äºº ğŸ¤–");
        }
      }
    }

    if(b.type===BLD.WALL){
      // walls generate defense power (abstract)
    }
  }

  // AENO mint demo (slow)
  game.resources.AENO += 0.08;

  // population growth if food surplus
  if(game.resources.Food > 200 && Math.random()<0.05){
    game.resources.Population += 1;
    aiSay("äººå£å¢åŠ  +1 ğŸ‘¥ï¼ˆé£Ÿç‰©å……è¶³ï¼‰");
  }
}

/* ===== Beast Tide ===== */
function spawnBeastTide(){
  warning.style.display="block";
  setTimeout(()=>warning.style.display="none",2500);

  aiSay("âš ï¸ ç¸æ½®ä¾†è¥²ï¼æˆ‘æœƒæŒ‡æ®åŸç‰†é˜²å®ˆï¼");

  // spawn beasts around territory border
  const cr = Math.floor(game.map.rows/2);
  const cc = Math.floor(game.map.cols/2);

  for(let i=0;i<10 + game.territory.radius*2;i++){
    const edge = Math.random()<0.5 ? "r" : "c";
    let r = cr, c = cc;

    if(edge==="r"){
      r = cr + (Math.random()<0.5 ? -game.territory.radius-2 : game.territory.radius+2);
      c = cc + Math.floor((Math.random()*game.territory.radius*2)-game.territory.radius);
    }else{
      c = cc + (Math.random()<0.5 ? -game.territory.radius-2 : game.territory.radius+2);
      r = cr + Math.floor((Math.random()*game.territory.radius*2)-game.territory.radius);
    }

    r = Math.max(0,Math.min(game.map.rows-1,r));
    c = Math.max(0,Math.min(game.map.cols-1,c));

    game.beasts.push({
      r,c,
      hp: 30 + Math.random()*30,
      kind: Math.random()<0.5 ? "ğŸº" : "ğŸ¦‡",
      t: performance.now()
    });
  }
}

/* ===== AI Chat ===== */
const chatLog = document.getElementById("chatLog");
function addMsg(type,text){
  const d=document.createElement("div");
  d.className="msg "+type;
  d.innerText=text;
  chatLog.appendChild(d);
  chatLog.scrollTop=chatLog.scrollHeight;
}
function aiSay(t){ addMsg("ai","ğŸ¦Š Vulpesï¼š "+t); }
function userSay(t){ addMsg("user",t); }

aiSay("AENO V3 æ–‡æ˜å¸åœ‹ç‰ˆå·²å•Ÿå‹•ã€‚åœ°å½¢æœ‰å±±æ²³æ£®æ—ç¤¦è„ˆï¼Œç¸æ½®æœƒå‘¨æœŸçˆ†ç™¼ã€‚ä½ å¯æ‹–æ›³/ç¸®æ”¾/é›™æŒ‡ç¸®æ”¾ã€‚");

/* ===== UI Update ===== */
function updateRes(){
  const list=document.getElementById("resList");
  list.innerHTML="";
  const arr=[
    ["ğŸª™ AENO",game.resources.AENO],
    ["ğŸ– Food",game.resources.Food],
    ["ğŸªµ Wood",game.resources.Wood],
    ["ğŸª¨ Stone",game.resources.Stone],
    ["â›“ï¸ Iron",game.resources.Iron],
    ["ğŸ… Gold",game.resources.Gold],
    ["ğŸ’ Crystal",game.resources.Crystal],
    ["âš¡ Energy",game.resources.Energy],
    ["ğŸ¤– Robots",game.resources.Robots],
    ["ğŸ‘¥ Pop",game.resources.Population]
  ];
  for(const [k,v] of arr){
    const row=document.createElement("div");
    row.className="resRow";
    row.innerHTML=`<span>${k}</span><span>${Math.floor(v)}</span>`;
    list.appendChild(row);
  }
}

function updateTime(){
  document.getElementById("timeText").innerText =
    `Year ${game.time.year} Â· Day ${game.time.day} Â· R=${game.territory.radius} Â· Ver ${APP_VERSION}`;
}

/* ===== Drawing ===== */
function drawCloud(cl){
  ctx.globalAlpha = cl.a;
  ctx.fillStyle="white";
  ctx.beginPath();
  ctx.arc(cl.x,cl.y,cl.s,0,Math.PI*2);
  ctx.arc(cl.x+cl.s*0.9,cl.y+cl.s*0.2,cl.s*0.8,0,Math.PI*2);
  ctx.arc(cl.x-cl.s*0.8,cl.y+cl.s*0.2,cl.s*0.7,0,Math.PI*2);
  ctx.fill();
  ctx.globalAlpha=1;
}

function drawTile(r,c){
  const t = game.mapData[r][c];
  const {x,y,ax,ay} = gridToScreen(r,c);

  let col1=C.grass1, col2=C.grass2;
  if(t.type===TILE.WATER){ col1=C.water1; col2=C.water2; }
  if(t.type===TILE.RIVER){ col1=C.river; col2="#7dd3fc"; }
  if(t.type===TILE.FOREST){ col1=C.forest1; col2=C.forest2; }
  if(t.type===TILE.HILL){ col1=C.hill1; col2=C.hill2; }
  if(t.type===TILE.MOUNTAIN){ col1=C.mountain1; col2=C.mountain2; }
  if(t.type===TILE.SAND){ col1=C.sand1; col2=C.sand2; }

  const grad = ctx.createLinearGradient(x-ax,y,x+ax,y+ay*2);
  grad.addColorStop(0,col1);
  grad.addColorStop(1,col2);

  ctx.beginPath();
  ctx.moveTo(x,y);
  ctx.lineTo(x+ax,y+ay);
  ctx.lineTo(x,y+ay*2);
  ctx.lineTo(x-ax,y+ay);
  ctx.closePath();

  ctx.fillStyle = grad;
  ctx.fill();

  // territory highlight
  if(insideTerritory(r,c)){
    ctx.strokeStyle="rgba(34,197,94,0.35)";
    ctx.lineWidth=2;
    ctx.stroke();
  }else{
    ctx.strokeStyle="rgba(0,0,0,0.05)";
    ctx.lineWidth=1;
    ctx.stroke();
  }

  // forest trees symbol
  if(t.type===TILE.FOREST && game.cam.zoom>0.55){
    ctx.fillStyle="rgba(0,0,0,0.18)";
    ctx.font="bold 12px system-ui";
    ctx.textAlign="center";
    ctx.fillText("ğŸŒ²",x,y+ay*1.1);
  }

  // mountain icon
  if(t.type===TILE.MOUNTAIN && game.cam.zoom>0.55){
    ctx.font="bold 12px system-ui";
    ctx.fillText("â›°ï¸",x,y+ay*1.1);
  }

  // vein mark
  if(t.vein && game.cam.zoom>0.7 && insideTerritory(r,c)){
    let icon="ğŸª¨";
    if(t.vein===VEIN.IRON) icon="â›“ï¸";
    if(t.vein===VEIN.GOLD) icon="ğŸ…";
    if(t.vein===VEIN.CRYSTAL) icon="ğŸ’";
    ctx.font="bold 12px system-ui";
    ctx.fillText(icon,x,y+ay*0.55);
  }
}

function drawBuilding(b){
  const {x,y} = gridToScreen(b.r,b.c);

  if(b.bounce>0){
    b.bounce -= 0.06;
    if(b.bounce<0) b.bounce=0;
  }
  const by = y + Math.sin(b.bounce*Math.PI)*18;

  // shadow
  ctx.fillStyle="rgba(0,0,0,0.20)";
  ctx.beginPath();
  ctx.ellipse(x,y+56,44,16,0,0,Math.PI*2);
  ctx.fill();

  if(game.selectedId===b.id){
    ctx.strokeStyle="rgba(59,130,246,0.9)";
    ctx.lineWidth=4;
    ctx.beginPath();
    ctx.ellipse(x,y+56,52,20,0,0,Math.PI*2);
    ctx.stroke();
  }

  // draw different types
  if(b.type===BLD.FARM){
    ctx.fillStyle="#a3e635";
    ctx.beginPath();
    ctx.roundRect(x-44,by+18,88,52,18);
    ctx.fill();

    ctx.fillStyle="rgba(0,0,0,0.12)";
    for(let i=0;i<6;i++){
      ctx.beginPath();
      ctx.roundRect(x-40+i*14,by+22,10,44,6);
      ctx.fill();
    }

    ctx.font="bold 14px system-ui";
    ctx.textAlign="center";
    ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.fillText("ğŸŒ¾",x,by+50);

  } else if(b.type===BLD.MINE){
    ctx.fillStyle="#94a3b8";
    ctx.beginPath();
    ctx.roundRect(x-46,by+18,92,56,18);
    ctx.fill();

    ctx.fillStyle="#475569";
    ctx.beginPath();
    ctx.arc(x,by+46,18,0,Math.PI*2);
    ctx.fill();

    ctx.fillStyle="rgba(255,255,255,0.5)";
    ctx.beginPath();
    ctx.arc(x-6,by+40,5,0,Math.PI*2);
    ctx.fill();

    ctx.font="bold 14px system-ui";
    ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.fillText("â›ï¸",x,by+50);

  } else if(b.type===BLD.FACTORY){
    ctx.fillStyle="#fde68a";
    ctx.beginPath();
    ctx.roundRect(x-48,by+18,96,58,18);
    ctx.fill();

    ctx.fillStyle="#f59e0b";
    ctx.beginPath();
    ctx.roundRect(x-18,by-6,36,30,12);
    ctx.fill();

    ctx.fillStyle="rgba(0,0,0,0.22)";
    ctx.beginPath();
    ctx.roundRect(x-32,by+40,18,18,6);
    ctx.roundRect(x-4,by+40,18,18,6);
    ctx.roundRect(x+24,by+40,18,18,6);
    ctx.fill();

    ctx.font="bold 14px system-ui";
    ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.fillText("ğŸ­",x,by+50);

  } else if(b.type===BLD.WALL){
    ctx.fillStyle="#cbd5e1";
    ctx.beginPath();
    ctx.roundRect(x-52,by+30,104,36,18);
    ctx.fill();

    ctx.fillStyle="rgba(0,0,0,0.20)";
    for(let i=0;i<5;i++){
      ctx.beginPath();
      ctx.roundRect(x-46+i*22,by+22,16,18,6);
      ctx.fill();
    }

    ctx.font="bold 14px system-ui";
    ctx.fillStyle="rgba(0,0,0,0.55)";
    ctx.fillText("ğŸ°",x,by+50);
  }

  // level tag
  ctx.fillStyle="rgba(0,0,0,0.65)";
  ctx.beginPath();
  ctx.roundRect(x-22,by-48,44,18,8);
  ctx.fill();
  ctx.fillStyle="white";
  ctx.font="bold 11px system-ui";
  ctx.fillText("Lv."+b.level,x,by-35);
}

function drawAnimal(a){
  const {x,y} = gridToScreen(a.r,a.c);
  ctx.font="bold 16px system-ui";
  ctx.textAlign="center";
  ctx.fillText(a.kind,x,y+30);
}

function drawBeast(b){
  const {x,y} = gridToScreen(b.r,b.c);
  ctx.font="bold 18px system-ui";
  ctx.textAlign="center";
  ctx.fillText(b.kind,x,y+30);
}

/* ===== AI assistant visual position ===== */
const aiBubble = document.getElementById("aiBubble");
const aiTag = document.getElementById("aiTag");

function updateAIBubble(){
  const p = gridToScreen(game.ai.x, game.ai.y);
  aiBubble.style.left = p.x+"px";
  aiBubble.style.top = (p.y+40)+"px";
  aiTag.style.left = p.x+"px";
  aiTag.style.top = (p.y+78)+"px";
}

/* ===== Movement ===== */
function stepAnimals(){
  for(const a of game.animals){
    if(performance.now() < a.t) continue;
    a.t = performance.now() + 600 + Math.random()*1400;

    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    const d = dirs[Math.floor(Math.random()*dirs.length)];
    const nr=a.r+d[0], nc=a.c+d[1];
    if(nr<0||nc<0||nr>=game.map.rows||nc>=game.map.cols) continue;
    if(game.mapData[nr][nc].type===TILE.WATER) continue;

    a.r=nr; a.c=nc;
  }
}

function stepAI(){
  if(performance.now() - game.ai.lastMove < 700) return;
  game.ai.lastMove = performance.now();

  // choose random target inside territory
  if(Math.random()<0.35){
    const cr=Math.floor(game.map.rows/2);
    const cc=Math.floor(game.map.cols/2);
    const rr = cr + Math.floor((Math.random()*game.territory.radius*2)-game.territory.radius);
    const rc = cc + Math.floor((Math.random()*game.territory.radius*2)-game.territory.radius);
    game.ai.tx = clamp(rr,0,game.map.rows-1);
    game.ai.ty = clamp(rc,0,game.map.cols-1);
  }

  const dr = Math.sign(game.ai.tx - game.ai.x);
  const dc = Math.sign(game.ai.ty - game.ai.y);
  const nr = game.ai.x + dr;
  const nc = game.ai.y + dc;

  if(nr<0||nc<0||nr>=game.map.rows||nc>=game.map.cols) return;
  if(game.mapData[nr][nc].type===TILE.WATER) return;

  game.ai.x = nr;
  game.ai.y = nc;
}

/* ===== Beast Tide Step ===== */
function stepBeasts(){
  if(game.beasts.length===0) return;

  const cr=Math.floor(game.map.rows/2);
  const cc=Math.floor(game.map.cols/2);

  // defense power from walls
  const wallCount = game.buildings.filter(b=>b.type===BLD.WALL).length;
  const defense = wallCount * 3 + (game.resources.Robots * 0.5);

  for(const beast of game.beasts){
    // move toward center
    const dr = Math.sign(cr - beast.r);
    const dc = Math.sign(cc - beast.c);

    if(Math.random()<0.6){
      beast.r = clamp(beast.r+dr,0,game.map.rows-1);
      beast.c = clamp(beast.c+dc,0,game.map.cols-1);
    }

    // if reached territory -> attack
    if(insideTerritory(beast.r,beast.c)){
      beast.hp -= (1.2 + defense*0.05);
      if(beast.hp<0) beast.hp=0;

      // beast damages food/wood
      if(Math.random()<0.15){
        game.resources.Food = Math.max(0, game.resources.Food - 5);
        game.resources.Wood = Math.max(0, game.resources.Wood - 2);
      }
    }
  }

  // remove dead
  game.beasts = game.beasts.filter(b=>b.hp>0);

  if(game.beasts.length===0){
    aiSay("âœ… ç¸æ½®å·²æ“Šé€€ï¼åŸç‰†èˆ‡æ©Ÿæ¢°äººè¡¨ç¾è‰¯å¥½ã€‚");
    showToast("ğŸ›¡ï¸ ç¸æ½®çµæŸ");
  }
}

/* ===== Zoom Controls ===== */
function setZoom(z, cx=innerWidth/2, cy=innerHeight/2){
  const old = game.cam.zoom;
  z = clamp(z, 0.35, 2.8);

  // zoom around pointer (camera compensation)
  const ratio = z / old;
  game.cam.x = cx - (cx - game.cam.x) * ratio;
  game.cam.y = cy - (cy - game.cam.y) * ratio;

  game.cam.zoom = z;
}

/* ===== Touch Drag + Pinch ===== */
let activeTouches = [];

cv.addEventListener("touchstart",(e)=>{
  e.preventDefault();
  activeTouches = [...e.touches];

  if(activeTouches.length===1){
    game.dragging=true;
    game.dragStart.x=activeTouches[0].clientX;
    game.dragStart.y=activeTouches[0].clientY;
    game.camStart.x=game.cam.x;
    game.camStart.y=game.cam.y;
  }

  if(activeTouches.length===2){
    game.pinch=true;
    const dx = activeTouches[0].clientX - activeTouches[1].clientX;
    const dy = activeTouches[0].clientY - activeTouches[1].clientY;
    game.pinchDist = Math.sqrt(dx*dx+dy*dy);
    game.pinchZoom = game.cam.zoom;
  }
},{passive:false});

cv.addEventListener("touchmove",(e)=>{
  e.preventDefault();
  activeTouches = [...e.touches];

  if(activeTouches.length===1 && game.dragging){
    const dx = activeTouches[0].clientX - game.dragStart.x;
    const dy = activeTouches[0].clientY - game.dragStart.y;
    game.cam.x = game.camStart.x + dx;
    game.cam.y = game.camStart.y + dy;
  }

  if(activeTouches.length===2 && game.pinch){
    const dx = activeTouches[0].clientX - activeTouches[1].clientX;
    const dy = activeTouches[0].clientY - activeTouches[1].clientY;
    const dist = Math.sqrt(dx*dx+dy*dy);
    const scale = dist / game.pinchDist;

    const cx = (activeTouches[0].clientX + activeTouches[1].clientX)/2;
    const cy = (activeTouches[0].clientY + activeTouches[1].clientY)/2;

    setZoom(game.pinchZoom * scale, cx, cy);
  }
},{passive:false});

cv.addEventListener("touchend",(e)=>{
  e.preventDefault();
  activeTouches = [...e.touches];
  if(activeTouches.length===0){
    game.dragging=false;
    game.pinch=false;
  }
},{passive:false});

/* Mouse drag + wheel zoom (desktop) */
cv.addEventListener("pointerdown",(e)=>{
  game.dragging=true;
  game.dragStart.x=e.clientX;
  game.dragStart.y=e.clientY;
  game.camStart.x=game.cam.x;
  game.camStart.y=game.cam.y;
});
cv.addEventListener("pointermove",(e)=>{
  if(!game.dragging) return;
  const dx=e.clientX-game.dragStart.x;
  const dy=e.clientY-game.dragStart.y;
  game.cam.x=game.camStart.x+dx;
  game.cam.y=game.camStart.y+dy;
});
cv.addEventListener("pointerup",()=>game.dragging=false);

cv.addEventListener("wheel",(e)=>{
  e.preventDefault();
  const delta = e.deltaY>0 ? -0.12 : 0.12;
  setZoom(game.cam.zoom + delta, e.clientX, e.clientY);
},{passive:false});

/* Tile selection for building placement */
cv.addEventListener("click",(e)=>{
  const mx = e.clientX;
  const my = e.clientY;

  // find nearest tile center by brute force (OK for 70x70)
  let best=null;
  let bestD=999999;

  for(let r=0;r<game.map.rows;r++){
    for(let c=0;c<game.map.cols;c++){
      const p=gridToScreen(r,c);
      const dx=mx-p.x;
      const dy=my-(p.y+30);
      const d=Math.sqrt(dx*dx+dy*dy);
      if(d<bestD){
        bestD=d;
        best={r,c};
      }
    }
  }

  if(best && bestD<80){
    game._placingTile = best;
    showToast(`ğŸ“ å·²é¸æ ¼ (${best.r},${best.c})`);

    // building click detection
    let clicked=null;
    for(const b of game.buildings){
      if(b.r===best.r && b.c===best.c){
        clicked=b;
        break;
      }
    }
    if(clicked){
      game.selectedId = clicked.id;
      clicked.bounce=1;
      aiSay(`ä½ é»ä¸­ã€Œ${clicked.type} Lv.${clicked.level}ã€ã€‚`);
    }
  }
});

/* ===== Buttons ===== */
document.getElementById("btnCenter").onclick=()=>{
  game.cam.x=0;game.cam.y=0;
  showToast("ğŸ“ å›åˆ°ä¸­å¿ƒ");
};

document.getElementById("btnZoomIn").onclick=()=> setZoom(game.cam.zoom+0.18);
document.getElementById("btnZoomOut").onclick=()=> setZoom(game.cam.zoom-0.18);

document.getElementById("btnSave").onclick=()=> saveGame(true);

document.getElementById("btnFarm").onclick=()=> addBuilding(BLD.FARM);
document.getElementById("btnMine").onclick=()=> addBuilding(BLD.MINE);
document.getElementById("btnFactory").onclick=()=> addBuilding(BLD.FACTORY);
document.getElementById("btnWall").onclick=()=> addBuilding(BLD.WALL);

document.getElementById("btnExpand").onclick=()=>{
  const cost = 80 + game.territory.radius*55;
  if(game.resources.AENO < cost){
    showToast("âŒ AENOä¸è¶³");
    aiSay(`æ“´åœ°éœ€è¦ ${cost} AENOï¼Œä½ å””å¤ ã€‚`);
    return;
  }
  game.resources.AENO -= cost;
  game.territory.radius++;
  showToast("ğŸ—ºï¸ é ˜åœŸæ“´å¼µæˆåŠŸï¼");
  aiSay("é ˜åœŸå·²æ“´å¼µï¼Œæˆ‘æœƒæ¢ç´¢æ–°å€åŸŸã€‚");
};

document.getElementById("btnRobot").onclick=()=>{
  if(game.resources.Robots<=0){
    showToast("âŒ ç„¡æ©Ÿæ¢°äºº");
    aiSay("ä½ æš«æ™‚æœªæœ‰æ©Ÿæ¢°äººï¼Œè¦èµ·å·¥å» ç”Ÿç”¢ã€‚");
    return;
  }
  game.resources.Robots -= 1;
  showToast("ğŸ¤– æ©Ÿæ¢°äººå‡ºç™¼æ¡é›†");
  aiSay("æ©Ÿæ¢°äººå·²å‡ºç™¼å»é æ–¹æ¡é›†ç¤¦ç”¢ã€‚");

  setTimeout(()=>{
    game.resources.Stone += 40;
    game.resources.Iron += 12;
    game.resources.Gold += 4;
    if(Math.random()<0.3) game.resources.Crystal += 1;
    game.resources.AENO += 4;
    aiSay("æ©Ÿæ¢°äººå›å ±ï¼šçŸ³+40 éµ+12 é‡‘+4 AENO+4");
  }, 1400);
};

/* ===== Panel Collapse ===== */
const resPanel=document.getElementById("resPanel");
const menuPanel=document.getElementById("menuPanel");
const chatPanel=document.getElementById("chatPanel");

const openRes=document.getElementById("openRes");
const openMenu=document.getElementById("openMenu");
const openChat=document.getElementById("openChat");

document.getElementById("collapseRes").onclick=()=>{resPanel.style.display="none";openRes.style.display="block";};
document.getElementById("collapseMenu").onclick=()=>{menuPanel.style.display="none";openMenu.style.display="block";};
document.getElementById("collapseChat").onclick=()=>{chatPanel.style.display="none";openChat.style.display="block";};

openRes.onclick=()=>{resPanel.style.display="block";openRes.style.display="none";};
openMenu.onclick=()=>{menuPanel.style.display="block";openMenu.style.display="none";};
openChat.onclick=()=>{chatPanel.style.display="flex";openChat.style.display="none";};

/* ===== Chat ===== */
document.getElementById("sendChat").onclick=()=>{
  const input=document.getElementById("chatText");
  const txt=input.value.trim();
  if(!txt) return;
  input.value="";
  userSay(txt);
  handleCommand(txt);
};
document.getElementById("chatText").addEventListener("keydown",(e)=>{
  if(e.key==="Enter") document.getElementById("sendChat").click();
});

function handleCommand(cmd){
  cmd=cmd.toLowerCase();

  if(cmd.includes("æ”¶")){
    game.resources.Wood += 30;
    game.resources.Stone += 20;
    game.resources.Food += 40;
    game.resources.AENO += 2;
    aiSay("å·²åŠ é€Ÿæ”¶è³‡æºï¼ˆæ–‡æ˜å¸åœ‹æ¨¡å¼ï¼‰ã€‚");
    showToast("ğŸ“¦ è³‡æºå·²æ”¶é›†");
    return;
  }

  if(cmd.includes("è¾²ç”°")){
    aiSay("æ”¶åˆ°ï¼Œæˆ‘æœƒå¹«ä½ å»ºé€ è¾²ç”°ã€‚è«‹å…ˆé»åœ°åœ–é¸æ ¼ã€‚");
    return;
  }

  if(cmd.includes("ç¤¦")){
    aiSay("æ”¶åˆ°ï¼Œæˆ‘æœƒå¹«ä½ å»ºé€ ç¤¦å ´ã€‚æœ€å¥½å»ºå–ºå±±æˆ–ä¸˜é™µç¤¦è„ˆã€‚");
    return;
  }

  if(cmd.includes("å·¥å» ")){
    aiSay("å·¥å» æœƒç”Ÿç”¢æ©Ÿæ¢°äººï¼Œéœ€è¦éµç¤¦æ”¯æŒã€‚");
    return;
  }

  if(cmd.includes("ç¸æ½®")){
    aiSay("ä½ æƒ³æå‰è§¸ç™¼ç¸æ½®ï¼Ÿæˆ‘å¯ä»¥æ¸¬è©¦ä¸€æ¬¡ã€‚");
    spawnBeastTide();
    return;
  }

  if(cmd.includes("é˜²å®ˆ")){
    aiSay("åŸç‰†æ•¸é‡è¶Šå¤šï¼Œé˜²å®ˆè¶Šå¼·ã€‚å·¥å» å‡ºç”¢æ©Ÿæ¢°äººäº¦å¯å”åŠ©é˜²å®ˆã€‚");
    return;
  }

  aiSay("æˆ‘ç†è§£ä½ æ„æ€ï¼Œä½†æ­¤æŒ‡ä»¤æœªå¯«å…¥å®Œæ•´è¦å‰‡ã€‚ä½ å¯ä»¥è¬›ï¼šæ”¶è³‡æº / ç¸æ½® / é˜²å®ˆã€‚");
}

/* ===== AI Bubble Click ===== */
aiBubble.onclick=()=>{
  if(chatPanel.style.display==="none"){
    chatPanel.style.display="flex";
    openChat.style.display="none";
  }
  aiSay("æˆ‘å–ºåº¦ï¼æƒ³æˆ‘åšå’©ï¼Ÿï¼ˆæ”¶è³‡æº/å»ºé€ /ç¸æ½®/é˜²å®ˆï¼‰");
};

/* ===== Save/Load Offline ===== */
function saveGame(manual=false){
  const save = {
    version: APP_VERSION,
    time: game.time,
    territory: game.territory,
    resources: game.resources,
    buildings: game.buildings,
    map: game.map,
    mapData: game.mapData,
    animals: game.animals
  };
  localStorage.setItem("AENO_V3_SAVE", JSON.stringify(save));
  localStorage.setItem("AENO_V3_LASTSAVE", ""+Date.now());
  if(manual){
    showToast("ğŸ’¾ å·²å­˜æª”ï¼ˆé›¢ç·šï¼‰");
    aiSay("å­˜æª”å®Œæˆã€‚å³ä½¿ç„¡ä¼ºæœå™¨éƒ½å¯ä»¥ç¹¼çºŒç©ã€‚");
  }
}

function loadGame(){
  const raw = localStorage.getItem("AENO_V3_SAVE");
  if(!raw) return false;

  try{
    const save = JSON.parse(raw);

    if(save.mapData && save.buildings){
      game.time = save.time;
      game.territory = save.territory;
      game.resources = save.resources;
      game.buildings = save.buildings;
      game.map = save.map;
      game.mapData = save.mapData;
      game.animals = save.animals || [];
      showToast("ğŸ“‚ å·²è®€å–é›¢ç·šå­˜æª”");
      aiSay("å·²è®€å–ä½ ä¸Šæ¬¡é›¢ç·šå­˜æª”ï¼Œæ–‡æ˜å¸åœ‹ç¹¼çºŒé‹è¡Œã€‚");
      return true;
    }
  }catch(e){
    console.log(e);
  }
  return false;
}

/* ===== Online Forced Update Record ===== */
async function checkOnlineUpdate(){
  const now = Date.now();
  if(now - game.online.lastCheck < 15000) return; // 15ç§’ä¸€æ¬¡
  game.online.lastCheck = now;

  if(!navigator.onLine) return;

  try{
    const res = await fetch(UPDATE_URL + "?v=" + now, {cache:"no-store"});
    if(!res.ok) return;

    const data = await res.json();
    // data example: { "latest":"AENO-V3-CIV-2026-02-14-02", "msg":"æ›´æ–°å…§å®¹..." }

    if(data.latest && data.latest !== APP_VERSION){
      game.online.updateAvailable = true;
      aiSay("âš ï¸ ç™¼ç¾æ–°ç‰ˆæœ¬æ›´æ–°ï¼è«‹åˆ·æ–°é é¢ç²å–æœ€æ–°éŠæˆ²ã€‚");
      showToast("âš ï¸ æœ‰æ–°ç‰ˆæœ¬ï¼Œè«‹åˆ·æ–°ï¼");
    }
  }catch(e){
    // offline safe
  }
}

/* ===== Main Draw ===== */
function draw(){
  // background
  const bg = ctx.createLinearGradient(0,0,0,innerHeight);
  bg.addColorStop(0,C.skyTop);
  bg.addColorStop(1,C.skyBot);
  ctx.fillStyle=bg;
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // clouds
  for(const cl of game.clouds){
    drawCloud(cl);
  }

  // tiles
  for(let r=0;r<game.map.rows;r++){
    for(let c=0;c<game.map.cols;c++){
      drawTile(r,c);
    }
  }

  // animals
  for(const a of game.animals) drawAnimal(a);

  // buildings depth sort
  const sorted=[...game.buildings].sort((a,b)=>(a.r+a.c)-(b.r+b.c));
  for(const b of sorted) drawBuilding(b);

  // beasts
  for(const b of game.beasts) drawBeast(b);

  // hint
  ctx.fillStyle="rgba(0,0,0,0.55)";
  ctx.font="bold 12px system-ui";
  ctx.textAlign="center";
  ctx.fillText("æ‹–æ›³åœ°åœ–ï½œé›™æŒ‡ç¸®æ”¾ï½œé»æ ¼å¾Œå»ºé€ ï½œæ£®æ—ç”¢æœ¨ï½œæ²³æµç”¢ç³§ï½œå±±ä¸˜å‡ºç¤¦ï½œç¸æ½®å‘¨æœŸä¾†è¥²", innerWidth/2, innerHeight-260);
}

/* ===== Tick ===== */
function tick(now){
  const dt = now - game.lastTick;
  game.lastTick = now;

  // time speed (demo)
  if(Math.random()<0.05){
    game.time.day++;
    if(game.time.day>365){
      game.time.day=1;
      game.time.year++;
    }
  }

  // cloud movement
  for(const cl of game.clouds){
    cl.x += cl.sp;
    if(cl.x>innerWidth+120){
      cl.x=-140;
      cl.y=60+Math.random()*220;
    }
  }

  // AI production every 1.2s
  if(now - game.lastAI > 1200){
    game.lastAI = now;
    produceTick();
    stepAnimals();
    stepAI();
    saveGame(false); // auto-save offline
  }

  // Beast tide every ~45 seconds (demo)
  if(now - game.lastBeast > 45000){
    game.lastBeast = now;
    spawnBeastTide();
  }

  stepBeasts();
  updateAIBubble();
  updateRes();
  updateTime();
  checkOnlineUpdate();
  draw();

  requestAnimationFrame(tick);
}

/* ===== Init ===== */
function init(){
  // try load offline
  const loaded = loadGame();
  if(!loaded){
    genWorld(987654321);
    // initial buildings
    const cr=Math.floor(game.map.rows/2);
    const cc=Math.floor(game.map.cols/2);

    game._placingTile={r:cr,c:cc};
    addBuilding(BLD.FARM);

    game._placingTile={r:cr+1,c:cc};
    addBuilding(BLD.MINE);

    game._placingTile={r:cr,c:cc+1};
    addBuilding(BLD.WALL);

    aiSay("æˆ‘å·²ç‚ºä½ å»ºç«‹åˆå§‹æ–‡æ˜ï¼šè¾²ç”°ã€ç¤¦å ´ã€åŸç‰†ã€‚ä¸‹ä¸€æ­¥å»ºå·¥å» å¯ç”Ÿç”¢æ©Ÿæ¢°äººã€‚");
    saveGame(false);
  }

  showToast("âœ… AENO V3 æ–‡æ˜å¸åœ‹å·²è¼‰å…¥");
  requestAnimationFrame(tick);
}
init();
</script>
</body>
</html>
