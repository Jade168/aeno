<!DOCTYPE html>
<html lang="zh-HK">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>AENO V3ï¼ˆç›´å±å¡é€šæ–‡æ˜ï¼‰</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:rgba(15,23,42,.92);
    --panel2:rgba(30,41,59,.92);
    --line:rgba(148,163,184,.25);
    --txt:#e2e8f0;
    --muted:#94a3b8;
    --good:#34d399;
    --warn:#fbbf24;
    --bad:#fb7185;
    --aeno:#60a5fa;
    --coin:#facc15;
    --btn:#1f2937;
    --btn2:#334155;
    --shadow:0 10px 30px rgba(0,0,0,.45);
  }
  html,body{
    margin:0;
    padding:0;
    height:100%;
    background:linear-gradient(180deg,#0b1220,#070b14);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans HK", "PingFang HK", sans-serif;
    color:var(--txt);
    overflow:hidden;
    touch-action:none;
  }
  #wrap{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  canvas{
    width:100vw;
    height:100vh;
    display:block;
    background:radial-gradient(circle at 50% 20%, #132039 0%, #081022 55%, #050812 100%);
  }

  /* TOP HUD */
  #topHUD{
    position:fixed;
    left:10px;
    right:10px;
    top:10px;
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:space-between;
    z-index:50;
    pointer-events:none;
  }
  .hudBox{
    pointer-events:auto;
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:14px;
    padding:8px 10px;
    box-shadow:var(--shadow);
    backdrop-filter: blur(10px);
    min-width:140px;
  }
  .hudRow{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    font-size:12px;
    line-height:1.2;
    white-space:nowrap;
  }
  .hudTitle{
    font-size:11px;
    color:var(--muted);
  }
  .hudVal{
    font-weight:700;
    font-size:12px;
  }
  .aenoVal{ color:var(--aeno); }
  .coinVal{ color:var(--coin); }

  #miniBtns{
    display:flex;
    gap:8px;
    pointer-events:auto;
  }
  .miniBtn{
    background:rgba(30,41,59,.92);
    border:1px solid var(--line);
    color:var(--txt);
    border-radius:14px;
    padding:10px 12px;
    font-size:12px;
    font-weight:700;
    cursor:pointer;
    box-shadow:var(--shadow);
  }
  .miniBtn:active{ transform:scale(.98); }

  /* DRAGGABLE PANEL */
  #panel{
    position:fixed;
    left:10px;
    bottom:110px; /* avoid Android nav bar */
    width:min(360px, 92vw);
    max-height:52vh;
    background:var(--panel);
    border:1px solid var(--line);
    border-radius:18px;
    box-shadow:var(--shadow);
    z-index:60;
    overflow:hidden;
    backdrop-filter: blur(10px);
    touch-action:none;
  }
  #panelHeader{
    background:rgba(2,6,23,.55);
    padding:10px 12px;
    border-bottom:1px solid var(--line);
    display:flex;
    align-items:center;
    justify-content:space-between;
    cursor:grab;
    user-select:none;
  }
  #panelHeader span{
    font-size:12px;
    font-weight:800;
    letter-spacing:.5px;
  }
  #panelHeader small{
    color:var(--muted);
    font-weight:600;
    font-size:11px;
  }
  #panelContent{
    padding:10px 10px 12px;
    overflow:auto;
    max-height:calc(52vh - 44px);
  }
  .grid2{
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:8px;
  }
  .btn{
    background:rgba(51,65,85,.55);
    border:1px solid rgba(148,163,184,.18);
    color:var(--txt);
    border-radius:14px;
    padding:10px 10px;
    font-size:12px;
    font-weight:800;
    cursor:pointer;
    user-select:none;
  }
  .btn:active{ transform:scale(.985); }
  .btn.good{ border-color:rgba(52,211,153,.45); }
  .btn.warn{ border-color:rgba(251,191,36,.45); }
  .btn.bad{ border-color:rgba(251,113,133,.45); }
  .btn small{
    display:block;
    font-size:10px;
    color:var(--muted);
    font-weight:600;
    margin-top:2px;
  }

  .statBox{
    background:rgba(2,6,23,.35);
    border:1px solid rgba(148,163,184,.12);
    border-radius:14px;
    padding:10px;
    margin-top:10px;
    font-size:12px;
    line-height:1.5;
  }
  .statBox b{ color:#fff; }
  .statLine{
    display:flex;
    justify-content:space-between;
    gap:10px;
    font-size:11px;
  }
  .statLine span{ color:var(--muted); }
  .statLine i{ font-style:normal; font-weight:800; color:var(--txt); }

  /* BUILD POPUP */
  #buildPopup{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    width:min(360px,92vw);
    background:rgba(15,23,42,.96);
    border:1px solid rgba(148,163,184,.2);
    border-radius:18px;
    box-shadow:var(--shadow);
    z-index:80;
    padding:12px;
    display:none;
    backdrop-filter: blur(10px);
  }
  #buildPopup h3{
    margin:0 0 8px 0;
    font-size:13px;
    letter-spacing:.5px;
  }
  #buildPopup p{
    margin:0 0 10px 0;
    color:var(--muted);
    font-size:11px;
    line-height:1.3;
  }
  #buildPopup .grid2{ margin-top:8px; }
  #buildClose{
    margin-top:10px;
    width:100%;
    background:rgba(51,65,85,.6);
    border:1px solid rgba(148,163,184,.2);
    color:var(--txt);
    border-radius:14px;
    padding:10px;
    font-weight:900;
    cursor:pointer;
  }

  /* ASSISTANT CHAT */
  #chatBox{
    position:fixed;
    right:10px;
    bottom:110px;
    width:min(320px, 92vw);
    background:rgba(15,23,42,.94);
    border:1px solid rgba(148,163,184,.2);
    border-radius:18px;
    box-shadow:var(--shadow);
    z-index:90;
    overflow:hidden;
    display:none;
    backdrop-filter: blur(10px);
  }
  #chatHead{
    padding:10px 12px;
    background:rgba(2,6,23,.55);
    border-bottom:1px solid rgba(148,163,184,.18);
    display:flex;
    justify-content:space-between;
    align-items:center;
    user-select:none;
  }
  #chatHead b{ font-size:12px; }
  #chatHead button{
    background:transparent;
    border:none;
    color:var(--muted);
    font-weight:900;
    font-size:14px;
    cursor:pointer;
  }
  #chatLog{
    padding:10px;
    max-height:240px;
    overflow:auto;
    font-size:12px;
    line-height:1.4;
  }
  .msg{
    margin:6px 0;
    padding:8px 10px;
    border-radius:14px;
    background:rgba(51,65,85,.35);
    border:1px solid rgba(148,163,184,.12);
  }
  .msg.ai{ border-color:rgba(96,165,250,.25); }
  .msg.you{ border-color:rgba(52,211,153,.25); }
  #chatInputRow{
    display:flex;
    gap:8px;
    padding:10px;
    border-top:1px solid rgba(148,163,184,.18);
  }
  #chatInput{
    flex:1;
    border-radius:14px;
    border:1px solid rgba(148,163,184,.18);
    background:rgba(2,6,23,.4);
    color:var(--txt);
    padding:10px;
    font-size:12px;
    outline:none;
  }
  #chatSend{
    border-radius:14px;
    border:1px solid rgba(148,163,184,.18);
    background:rgba(51,65,85,.6);
    color:var(--txt);
    font-weight:900;
    padding:10px 12px;
    cursor:pointer;
  }

  /* SMALL NOTICE */
  #toast{
    position:fixed;
    left:50%;
    bottom:24px;
    transform:translateX(-50%);
    background:rgba(2,6,23,.78);
    border:1px solid rgba(148,163,184,.2);
    color:var(--txt);
    padding:10px 14px;
    border-radius:16px;
    font-size:12px;
    z-index:100;
    display:none;
    box-shadow:var(--shadow);
    max-width:92vw;
    text-align:center;
    backdrop-filter: blur(10px);
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="game"></canvas>
</div>

<!-- TOP HUD -->
<div id="topHUD">
  <div class="hudBox">
    <div class="hudRow">
      <div>
        <div class="hudTitle">é‡‘å¹£</div>
        <div class="hudVal coinVal" id="coinText">0</div>
      </div>
      <div style="text-align:right">
        <div class="hudTitle">AENO</div>
        <div class="hudVal aenoVal" id="aenoText">0.0000</div>
      </div>
    </div>
  </div>

  <div id="miniBtns">
    <button class="miniBtn" id="btnPanel">é¢æ¿</button>
    <button class="miniBtn" id="btnZoomIn">ï¼‹</button>
    <button class="miniBtn" id="btnZoomOut">ï¼</button>
  </div>
</div>

<!-- MAIN PANEL -->
<div id="panel">
  <div id="panelHeader">
    <span>æ–‡æ˜é¢æ¿</span>
    <small id="panelHint">å¯æ‹–æ‹‰ï½œå¯æ”¶èµ·</small>
  </div>
  <div id="panelContent">
    <div class="grid2">
      <button class="btn good" id="btnAutoOn">AI è‡ªå‹•ï¼šé–‹<small>åŠ©æ‰‹æœƒå»ºé€ /å‡ç´š</small></button>
      <button class="btn bad" id="btnAutoOff">AI è‡ªå‹•ï¼šé—œ<small>åªæ”¶è³‡æº</small></button>

      <button class="btn warn" id="btnPriorityWood">å„ªå…ˆï¼šæœ¨æ<small>å…ˆèµ·ä¼æœ¨/å€‰åº«</small></button>
      <button class="btn warn" id="btnPriorityStone">å„ªå…ˆï¼šçŸ³é ­<small>å…ˆèµ·æ¡çŸ³/é“è·¯</small></button>

      <button class="btn warn" id="btnPriorityIron">å„ªå…ˆï¼šéµç¤¦<small>å…ˆèµ·ç¤¦å ´/å†¶ç…‰</small></button>
      <button class="btn warn" id="btnPriorityFood">å„ªå…ˆï¼šé£Ÿç‰©<small>å…ˆèµ·è¾²ç”°/å±‹</small></button>

      <button class="btn" id="btnRobotSend">æ´¾æ©Ÿå™¨äººå‡ºç™¼<small>éš¨æ©Ÿå»è¡Œæ˜Ÿ</small></button>
      <button class="btn" id="btnAdSong">æ’­æ”¾å»£å‘Š/æ­Œæ›²<small>æ¸¬è©¦éŸ³æ•ˆ + åˆ†æ•¸</small></button>

      <button class="btn" id="btnMarket">äº¤æ˜“æ‰€<small>è²·è³£è³‡æº</small></button>
      <button class="btn" id="btnTech">ç§‘æŠ€æ¨¹<small>æ–‡æ˜è§£é–</small></button>
    </div>

    <div class="statBox">
      <div class="statLine"><span>æœ¨æ</span><i id="woodText">0</i></div>
      <div class="statLine"><span>çŸ³é ­</span><i id="stoneText">0</i></div>
      <div class="statLine"><span>éµç¤¦</span><i id="ironText">0</i></div>
      <div class="statLine"><span>é£Ÿç‰©</span><i id="foodText">0</i></div>
      <div class="statLine"><span>äººå£</span><i id="popText">0</i></div>
      <div class="statLine"><span>é ˜åœŸ</span><i id="landText">0</i></div>
      <div class="statLine"><span>æ–‡æ˜å¹´ä»£</span><i id="yearText">0</i></div>
    </div>

    <div class="statBox">
      <b>æç¤ºï¼š</b><br/>
      é»ç©ºåœ°å³å¯èµ·å»ºç¯‰ã€‚<br/>
      é» AI åŠ©æ‰‹å¯é–‹å°è©±ã€‚<br/>
      é›¢ç·šæœ€å¤šè£œç®— 24 å°æ™‚ã€‚
    </div>
  </div>
</div>

<!-- BUILD POPUP -->
<div id="buildPopup">
  <h3>å»ºç¯‰é¸å–®</h3>
  <p id="buildInfo">é¸æ“‡è¦èµ·å˜…å»ºç¯‰</p>

  <div class="grid2">
    <button class="btn good" data-build="house">æˆ¿å±‹<small>+äººå£ä¸Šé™</small></button>
    <button class="btn good" data-build="farm">è¾²ç”°<small>ç”¢é£Ÿç‰©</small></button>

    <button class="btn warn" data-build="lumber">ä¼æœ¨å ´<small>ç”¢æœ¨æ</small></button>
    <button class="btn warn" data-build="quarry">æ¡çŸ³å ´<small>ç”¢çŸ³é ­</small></button>

    <button class="btn warn" data-build="mine">éµç¤¦å ´<small>ç”¢éµç¤¦</small></button>
    <button class="btn" data-build="factory">å·¥å» <small>è§£é–æ©Ÿå™¨äºº</small></button>
  </div>

  <button id="buildClose">å–æ¶ˆ</button>
</div>

<!-- CHAT -->
<div id="chatBox">
  <div id="chatHead">
    <b>AI åŠ©æ‰‹ï¼ˆå°å‹•ç‰©ï¼‰</b>
    <button id="chatClose">âœ•</button>
  </div>
  <div id="chatLog"></div>
  <div id="chatInputRow">
    <input id="chatInput" placeholder="è¼¸å…¥æŒ‡ä»¤ï¼šå·¡é‚ / æ”¶é›† / å»ºé€  / å‡ç´š..." />
    <button id="chatSend">é€å‡º</button>
  </div>
</div>

<div id="toast"></div>

<script>
/* ===============================
   AENO V3 - Single File Version
   - Chrome/Edge Compatible
   - Draggable panel
   - Tap empty tile to build
   - Workers + animals moving
   - AI assistant with chat
   - Offline simulate 24h max
   - AENO slowed down
================================= */

(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false });

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resize);
  resize();

  // UI refs
  const panel = document.getElementById("panel");
  const panelHeader = document.getElementById("panelHeader");
  const btnPanel = document.getElementById("btnPanel");

  const coinText = document.getElementById("coinText");
  const aenoText = document.getElementById("aenoText");

  const woodText = document.getElementById("woodText");
  const stoneText = document.getElementById("stoneText");
  const ironText = document.getElementById("ironText");
  const foodText = document.getElementById("foodText");
  const popText = document.getElementById("popText");
  const landText = document.getElementById("landText");
  const yearText = document.getElementById("yearText");

  const btnZoomIn = document.getElementById("btnZoomIn");
  const btnZoomOut = document.getElementById("btnZoomOut");

  const btnAutoOn = document.getElementById("btnAutoOn");
  const btnAutoOff = document.getElementById("btnAutoOff");

  const btnPriorityWood = document.getElementById("btnPriorityWood");
  const btnPriorityStone = document.getElementById("btnPriorityStone");
  const btnPriorityIron = document.getElementById("btnPriorityIron");
  const btnPriorityFood = document.getElementById("btnPriorityFood");

  const btnRobotSend = document.getElementById("btnRobotSend");
  const btnAdSong = document.getElementById("btnAdSong");
  const btnMarket = document.getElementById("btnMarket");
  const btnTech = document.getElementById("btnTech");

  const buildPopup = document.getElementById("buildPopup");
  const buildClose = document.getElementById("buildClose");
  const buildInfo = document.getElementById("buildInfo");

  const chatBox = document.getElementById("chatBox");
  const chatLog = document.getElementById("chatLog");
  const chatInput = document.getElementById("chatInput");
  const chatSend = document.getElementById("chatSend");
  const chatClose = document.getElementById("chatClose");

  const toast = document.getElementById("toast");

  function showToast(msg, ms=1500){
    toast.style.display="block";
    toast.textContent = msg;
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toast.style.display="none", ms);
  }

  // ===============================
  // GAME CONSTANTS
  // ===============================
  const GAME_TIME_SPEED = 10 * 365; // 1 real day = 10 in-game years => 3650 days factor
  const TILE = 56;
  const MAP_W = 22;
  const MAP_H = 22;

  // camera
  let camX = 0;
  let camY = 0;
  let zoom = 1.05; // better default
  const ZOOM_MIN = 0.65;
  const ZOOM_MAX = 2.15;

  // ===============================
  // SAVE SYSTEM
  // ===============================
  const SAVE_KEY = "AENO_V3_SAVE";
  function now(){ return Date.now(); }

  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function randi(min,max){ return Math.floor(rand(min,max+1)); }

  // ===============================
  // WORLD GEN
  // ===============================
  const TILE_TYPES = {
    grass:"grass",
    forest:"forest",
    rock:"rock",
    iron:"iron",
    water:"water",
    sand:"sand",
  };

  const BUILDINGS = {
    house:"house",
    farm:"farm",
    lumber:"lumber",
    quarry:"quarry",
    mine:"mine",
    factory:"factory"
  };

  function makeEmptyMap(){
    const arr = [];
    for(let y=0;y<MAP_H;y++){
      const row=[];
      for(let x=0;x<MAP_W;x++){
        row.push({ t:TILE_TYPES.grass, b:null, lv:1 });
      }
      arr.push(row);
    }
    return arr;
  }

  function generateWorld(map){
    // base
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W;x++){
        map[y][x].t = TILE_TYPES.grass;
        map[y][x].b = null;
        map[y][x].lv = 1;
      }
    }

    // water patches
    for(let i=0;i<3;i++){
      const cx=randi(3,MAP_W-4);
      const cy=randi(3,MAP_H-4);
      for(let y=-2;y<=2;y++){
        for(let x=-2;x<=2;x++){
          if(Math.random()<0.45){
            const px=cx+x, py=cy+y;
            if(px>=0&&py>=0&&px<MAP_W&&py<MAP_H) map[py][px].t=TILE_TYPES.water;
          }
        }
      }
    }

    // forest zones
    for(let i=0;i<4;i++){
      const cx=randi(2,MAP_W-3);
      const cy=randi(2,MAP_H-3);
      for(let y=-3;y<=3;y++){
        for(let x=-3;x<=3;x++){
          const px=cx+x, py=cy+y;
          if(px>=0&&py>=0&&px<MAP_W&&py<MAP_H){
            if(map[py][px].t!==TILE_TYPES.water && Math.random()<0.65){
              map[py][px].t=TILE_TYPES.forest;
            }
          }
        }
      }
    }

    // rock zones
    for(let i=0;i<3;i++){
      const cx=randi(2,MAP_W-3);
      const cy=randi(2,MAP_H-3);
      for(let y=-2;y<=2;y++){
        for(let x=-2;x<=2;x++){
          const px=cx+x, py=cy+y;
          if(px>=0&&py>=0&&px<MAP_W&&py<MAP_H){
            if(map[py][px].t!==TILE_TYPES.water && Math.random()<0.55){
              map[py][px].t=TILE_TYPES.rock;
            }
          }
        }
      }
    }

    // iron veins
    for(let i=0;i<2;i++){
      const cx=randi(3,MAP_W-4);
      const cy=randi(3,MAP_H-4);
      for(let y=-2;y<=2;y++){
        for(let x=-2;x<=2;x++){
          const px=cx+x, py=cy+y;
          if(px>=0&&py>=0&&px<MAP_W&&py<MAP_H){
            if(map[py][px].t!==TILE_TYPES.water && Math.random()<0.35){
              map[py][px].t=TILE_TYPES.iron;
            }
          }
        }
      }
    }

    // sand around water
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W;x++){
        if(map[y][x].t===TILE_TYPES.grass && hasNeighborType(map,x,y,TILE_TYPES.water)){
          if(Math.random()<0.55) map[y][x].t=TILE_TYPES.sand;
        }
      }
    }
  }

  function hasNeighborType(map,x,y,type){
    for(let dy=-1;dy<=1;dy++){
      for(let dx=-1;dx<=1;dx++){
        if(dx===0&&dy===0) continue;
        const nx=x+dx, ny=y+dy;
        if(nx>=0&&ny>=0&&nx<MAP_W&&ny<MAP_H){
          if(map[ny][nx].t===type) return true;
        }
      }
    }
    return false;
  }

  // ===============================
  // GAME STATE
  // ===============================
  const state = {
    map: makeEmptyMap(),
    coin: 220,        // start higher for early fun
    aeno: 0.0000,
    wood: 80,
    stone: 50,
    iron: 10,
    food: 90,
    pop: 4,
    land: 12,
    year: 0,
    autoAI: true,
    aiPriority: "wood",
    lastTick: now(),
    lastSave: now(),
    lastOnline: now(),
    adScore: 0,
    learnScore: 0,
    buildScore: 0,
    ecoScore: 0,
    activeScore: 0,
    adPlayCount: 0,
    robotTrips: 0,
    beastsKilled: 0,
    beastFragments: 0,
    offlineCapHours: 24,
    baseTerritory: {x:10,y:10,r:3},
    buildingsCount: {
      house:0,farm:0,lumber:0,quarry:0,mine:0,factory:0
    }
  };

  // ===============================
  // ENTITY SYSTEM
  // ===============================
  const workers = [];
  const animals = [];

  function spawnWorkers(){
    workers.length = 0;
    for(let i=0;i<state.pop;i++){
      workers.push({
        x: state.baseTerritory.x + rand(-1,1),
        y: state.baseTerritory.y + rand(-1,1),
        tx: state.baseTerritory.x + rand(-2,2),
        ty: state.baseTerritory.y + rand(-2,2),
        speed: rand(0.6, 1.0),
        carry: null,
        mood: rand(0,1)
      });
    }
  }

  function spawnAnimals(){
    animals.length = 0;
    const count = 8;
    for(let i=0;i<count;i++){
      animals.push({
        x: randi(2,MAP_W-3),
        y: randi(2,MAP_H-3),
        tx: randi(2,MAP_W-3),
        ty: randi(2,MAP_H-3),
        speed: rand(0.35, 0.7),
        type: Math.random()<0.5 ? "boar":"fox",
        wobble: rand(0,10)
      });
    }
  }

  // assistant (animal)
  const assistant = {
    x: state.baseTerritory.x + 0.2,
    y: state.baseTerritory.y - 0.4,
    tx: state.baseTerritory.x,
    ty: state.baseTerritory.y,
    speed: 0.55,
    mood: 0,
    flagWave: 0
  };

  // ===============================
  // DRAW HELPERS (NO roundRect)
  // ===============================
  function roundedRectPath(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.lineTo(x+w-r,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r);
    ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r);
    ctx.quadraticCurveTo(x,y,x+r,y);
    ctx.closePath();
  }

  function drawShadowCircle(cx,cy,rx,ry,alpha=0.18){
    ctx.save();
    ctx.fillStyle = `rgba(0,0,0,${alpha})`;
    ctx.beginPath();
    ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // ===============================
  // TILE TO SCREEN
  // ===============================
  function tileToScreen(tx,ty){
    const x = tx * TILE;
    const y = ty * TILE;
    return { x, y };
  }

  function screenToTile(px,py){
    const x = (px - camX) / zoom;
    const y = (py - camY) / zoom;
    return {
      tx: Math.floor(x / TILE),
      ty: Math.floor(y / TILE)
    };
  }

  // ===============================
  // TERRITORY CHECK
  // ===============================
  function inTerritory(x,y){
    const dx = x - state.baseTerritory.x;
    const dy = y - state.baseTerritory.y;
    return (dx*dx + dy*dy) <= (state.baseTerritory.r*state.baseTerritory.r);
  }

  // ===============================
  // BUILD COSTS
  // ===============================
  const cost = {
    house:  { coin:80, wood:35, stone:15, iron:0, food:0 },
    farm:   { coin:60, wood:20, stone:5, iron:0, food:0 },
    lumber: { coin:55, wood:0,  stone:10, iron:0, food:0 },
    quarry: { coin:65, wood:15, stone:0,  iron:0, food:0 },
    mine:   { coin:90, wood:25, stone:20, iron:0, food:0 },
    factory:{ coin:140,wood:40, stone:40, iron:20,food:0 }
  };

  function canPay(c){
    return state.coin>=c.coin &&
      state.wood>=c.wood &&
      state.stone>=c.stone &&
      state.iron>=c.iron &&
      state.food>=c.food;
  }

  function pay(c){
    state.coin -= c.coin;
    state.wood -= c.wood;
    state.stone -= c.stone;
    state.iron -= c.iron;
    state.food -= c.food;
  }

  // ===============================
  // PLACE BUILDING
  // ===============================
  function placeBuilding(tx,ty,type){
    if(tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return false;
    const cell = state.map[ty][tx];

    if(cell.t===TILE_TYPES.water) { showToast("å‘¢åº¦ä¿‚æ°´ï¼Œèµ·å””åˆ°"); return false; }
    if(cell.b) { showToast("å‘¢åº¦å·²æœ‰å»ºç¯‰"); return false; }
    if(!inTerritory(tx,ty)) { showToast("å””ä¿‚é ˜åœŸå…§"); return false; }

    const c = cost[type];
    if(!canPay(c)){
      showToast("è³‡æºä¸è¶³ï¼ˆéœ€è¦é‡‘å¹£/æœ¨/çŸ³/éµï¼‰", 1700);
      return false;
    }

    pay(c);
    cell.b = type;
    cell.lv = 1;

    state.buildScore += 6;
    state.ecoScore += 2;

    state.buildingsCount[type] = (state.buildingsCount[type]||0) + 1;

    if(type==="house"){
      state.pop += 2;
      spawnWorkers();
      state.coin += 10; // house gives immediate tax boost
    }

    if(type==="factory"){
      state.coin += 25;
    }

    showToast("å»ºç¯‰å®Œæˆï¼š" + typeName(type));
    return true;
  }

  function typeName(type){
    const map = {
      house:"æˆ¿å±‹",
      farm:"è¾²ç”°",
      lumber:"ä¼æœ¨å ´",
      quarry:"æ¡çŸ³å ´",
      mine:"éµç¤¦å ´",
      factory:"å·¥å» "
    };
    return map[type] || type;
  }

  // ===============================
  // BUILD POPUP SYSTEM
  // ===============================
  let buildTarget = null;

  function openBuildPopup(tx,ty){
    buildTarget = {tx,ty};
    buildInfo.textContent = `ä½ç½®ï¼š(${tx},${ty})ï½œé ˜åœŸå…§å¯å»ºé€ `;
    buildPopup.style.display = "block";
  }

  function closeBuildPopup(){
    buildPopup.style.display = "none";
    buildTarget = null;
  }

  buildClose.onclick = closeBuildPopup;

  buildPopup.addEventListener("click",(e)=>{
    const btn = e.target.closest("button[data-build]");
    if(!btn) return;
    if(!buildTarget) return;

    const type = btn.getAttribute("data-build");
    placeBuilding(buildTarget.tx, buildTarget.ty, type);
    closeBuildPopup();
  });

  // ===============================
  // AI LOGIC
  // ===============================
  function aiChooseBuild(){
    // ensure basics: houses first
    if(state.buildingsCount.house < 2) return "house";
    if(state.buildingsCount.lumber < 1) return "lumber";
    if(state.buildingsCount.farm < 1) return "farm";
    if(state.buildingsCount.quarry < 1) return "quarry";
    if(state.buildingsCount.mine < 1) return "mine";

    // priority
    if(state.aiPriority==="wood") return state.buildingsCount.lumber < 3 ? "lumber" : "house";
    if(state.aiPriority==="stone") return state.buildingsCount.quarry < 3 ? "quarry" : "house";
    if(state.aiPriority==="iron") return state.buildingsCount.mine < 2 ? "mine" : "factory";
    if(state.aiPriority==="food") return state.buildingsCount.farm < 3 ? "farm" : "house";

    return "house";
  }

  function findBuildSpot(){
    const bx = state.baseTerritory.x;
    const by = state.baseTerritory.y;

    for(let tries=0;tries<120;tries++){
      const tx = bx + randi(-state.baseTerritory.r, state.baseTerritory.r);
      const ty = by + randi(-state.baseTerritory.r, state.baseTerritory.r);
      if(tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) continue;

      const cell = state.map[ty][tx];
      if(!inTerritory(tx,ty)) continue;
      if(cell.t===TILE_TYPES.water) continue;
      if(cell.b) continue;

      return {tx,ty};
    }
    return null;
  }

  function aiBuildTick(){
    if(!state.autoAI) return;

    // if too poor, don't spam
    if(state.coin < 40) return;

    const type = aiChooseBuild();
    const spot = findBuildSpot();
    if(!spot) return;

    // if cannot pay, skip
    if(!canPay(cost[type])) return;

    placeBuilding(spot.tx, spot.ty, type);
  }

  // ===============================
  // RESOURCE PRODUCTION
  // ===============================
  function countBuildings(type){
    let c=0;
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W;x++){
        if(state.map[y][x].b===type) c++;
      }
    }
    return c;
  }

  function productionTick(dtDays){
    // base income: taxes
    const houses = countBuildings("house");
    const farms = countBuildings("farm");
    const lumbers = countBuildings("lumber");
    const quarries = countBuildings("quarry");
    const mines = countBuildings("mine");
    const factories = countBuildings("factory");

    // coins (faster early game)
    let coinGain = (houses*0.55 + factories*0.35 + farms*0.15) * dtDays;
    coinGain += (state.pop*0.03) * dtDays;

    // resources
    let woodGain = (lumbers*0.85) * dtDays;
    let stoneGain = (quarries*0.65) * dtDays;
    let ironGain = (mines*0.28) * dtDays;
    let foodGain = (farms*0.75) * dtDays;

    // workers passive gathering (makes early game not stuck)
    woodGain += (state.pop*0.06) * dtDays;
    foodGain += (state.pop*0.04) * dtDays;

    // territory exploration rewards (auto coin)
    const explore = (state.pop*0.012) * dtDays;
    state.ecoScore += explore;

    state.coin += coinGain;
    state.wood += woodGain;
    state.stone += stoneGain;
    state.iron += ironGain;
    state.food += foodGain;

    // eco score
    state.ecoScore += (woodGain+stoneGain+ironGain+foodGain)*0.02;

    // clamp
    state.coin = Math.min(state.coin, 99999999);
    state.wood = Math.min(state.wood, 99999999);
    state.stone = Math.min(state.stone, 99999999);
    state.iron = Math.min(state.iron, 99999999);
    state.food = Math.min(state.food, 99999999);
  }

  // ===============================
  // TERRITORY EXPAND (auto with coin)
  // ===============================
  function territoryTick(dtDays){
    // expand slowly but automatic if coin available
    const needCoin = 120 + state.baseTerritory.r*55;
    if(state.coin > needCoin && Math.random() < (0.015*dtDays)){
      state.coin -= Math.floor(needCoin*0.65);
      state.baseTerritory.r = Math.min(9, state.baseTerritory.r + 1);
      state.land = Math.floor(Math.PI * state.baseTerritory.r * state.baseTerritory.r);
      showToast("é ˜åœŸæ“´å¤§ï¼åŠå¾‘ +" + 1);
      state.buildScore += 4;
    }
  }

  // ===============================
  // BEAST TIDE (only when city complete)
  // ===============================
  function cityCompletion(){
    // completion based on basic buildings existence
    const h=countBuildings("house");
    const f=countBuildings("farm");
    const l=countBuildings("lumber");
    const q=countBuildings("quarry");
    const m=countBuildings("mine");
    // need minimum set
    const done = (h>=2 && f>=1 && l>=1 && q>=1 && m>=1);
    return done ? 1 : 0;
  }

  let beastTimer = 0;

  function beastTick(dtDays){
    if(cityCompletion() < 1) return;

    beastTimer += dtDays;

    // every ~3-6 in-game months
    const trigger = 0.25 + Math.random()*0.25;
    if(beastTimer >= trigger){
      beastTimer = 0;

      const kill = randi(1, 3 + Math.floor(state.baseTerritory.r/2));
      state.beastsKilled += kill;
      const frag = kill * randi(1,3);

      state.beastFragments += frag;
      state.coin += kill * 8;

      showToast("ç¸æ½®ä¾†è¥²ï¼æ“Šé€€ +" + kill + "ï½œç¢ç‰‡ +" + frag, 1800);

      state.learnScore += 1.2; // learning beast names
      state.ecoScore += 0.8;
    }
  }

  // ===============================
  // AENO ALGORITHM (SLOW)
  // ===============================
  function hiddenMixNumber(n){
    // no direct mapping exposed; just mixing
    const s = Math.sin(n*12.9898)*43758.5453;
    return s - Math.floor(s);
  }

  function calcAenoMint(dtDays){
    // base mint pool extremely small
    // you won't get "few AENO in 5 minutes" anymore
    const basePoolPerDay = 0.00055; // VERY slow base
    const days = dtDays;

    // scores decay slightly
    state.adScore *= 0.999;
    state.learnScore *= 0.999;
    state.buildScore *= 0.9995;
    state.ecoScore *= 0.9995;
    state.activeScore *= 0.999;

    // contribution
    const share =
      state.adScore*0.40 +
      state.learnScore*0.25 +
      state.buildScore*0.15 +
      state.ecoScore*0.15 +
      state.activeScore*0.05;

    const seed = (state.lastOnline/1000) + state.robotTrips*17 + state.beastFragments*3.3;
    const chaos = 0.85 + hiddenMixNumber(seed)*0.35;

    // clamp share so it can't explode
    const safeShare = clamp(share, 0, 180);

    // mint
    let mint = basePoolPerDay * days * (1 + safeShare/55) * chaos;

    // fragments allow slightly more mint (but not huge)
    mint *= (1 + clamp(state.beastFragments/2000, 0, 0.55));

    // absolute cap
    mint = clamp(mint, 0, 0.015);

    state.aeno += mint;

    // convert fragments slowly
    if(state.beastFragments >= 20 && Math.random()<0.12){
      state.beastFragments -= 10;
      state.aeno += 0.0012;
    }
  }

  // ===============================
  // OFFLINE SIMULATION (24h cap)
  // ===============================
  function simulateOffline(){
    const saved = loadSaveRaw();
    if(!saved) return;

    const last = saved.lastOnline || saved.lastTick || now();
    const diffMs = now() - last;
    if(diffMs < 6000) return;

    const maxMs = state.offlineCapHours * 3600 * 1000;
    const simMs = Math.min(diffMs, maxMs);

    const simDays = (simMs / (1000*60*60*24)) * GAME_TIME_SPEED;

    if(simDays > 0.02){
      productionTick(simDays);
      territoryTick(simDays);
      beastTick(simDays);
      calcAenoMint(simDays);

      showToast("é›¢ç·šè£œç®—å®Œæˆï¼ˆæœ€å¤š24å°æ™‚ï¼‰", 2000);
    }

    state.lastOnline = now();
  }

  // ===============================
  // SAVE / LOAD
  // ===============================
  function saveGame(){
    const data = {
      ...state,
      map: state.map,
      workers,
      animals,
      assistant,
      lastOnline: now()
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(data));
    state.lastSave = now();
  }

  function loadSaveRaw(){
    try{
      const s = localStorage.getItem(SAVE_KEY);
      if(!s) return null;
      return JSON.parse(s);
    }catch(e){
      return null;
    }
  }

  function loadGame(){
    const data = loadSaveRaw();
    if(!data){
      generateWorld(state.map);

      // starter buildings
      placeStarterBuildings();

      spawnWorkers();
      spawnAnimals();
      saveGame();
      return;
    }

    // restore
    state.coin = data.coin ?? state.coin;
    state.aeno = data.aeno ?? state.aeno;
    state.wood = data.wood ?? state.wood;
    state.stone = data.stone ?? state.stone;
    state.iron = data.iron ?? state.iron;
    state.food = data.food ?? state.food;
    state.pop = data.pop ?? state.pop;
    state.land = data.land ?? state.land;
    state.year = data.year ?? state.year;
    state.autoAI = data.autoAI ?? state.autoAI;
    state.aiPriority = data.aiPriority ?? state.aiPriority;
    state.lastTick = data.lastTick ?? now();
    state.lastSave = data.lastSave ?? now();
    state.lastOnline = data.lastOnline ?? now();

    state.adScore = data.adScore ?? 0;
    state.learnScore = data.learnScore ?? 0;
    state.buildScore = data.buildScore ?? 0;
    state.ecoScore = data.ecoScore ?? 0;
    state.activeScore = data.activeScore ?? 0;

    state.adPlayCount = data.adPlayCount ?? 0;
    state.robotTrips = data.robotTrips ?? 0;
    state.beastsKilled = data.beastsKilled ?? 0;
    state.beastFragments = data.beastFragments ?? 0;

    state.baseTerritory = data.baseTerritory ?? state.baseTerritory;
    state.buildingsCount = data.buildingsCount ?? state.buildingsCount;

    if(data.map) state.map = data.map;

    if(Array.isArray(data.workers)){
      workers.length = 0;
      data.workers.forEach(w=>workers.push(w));
    }else{
      spawnWorkers();
    }

    if(Array.isArray(data.animals)){
      animals.length = 0;
      data.animals.forEach(a=>animals.push(a));
    }else{
      spawnAnimals();
    }

    if(data.assistant){
      assistant.x = data.assistant.x ?? assistant.x;
      assistant.y = data.assistant.y ?? assistant.y;
      assistant.tx = data.assistant.tx ?? assistant.tx;
      assistant.ty = data.assistant.ty ?? assistant.ty;
    }

    // fix if world corrupted
    if(!state.map || !state.map[0] || !state.map[0][0]){
      state.map = makeEmptyMap();
      generateWorld(state.map);
      placeStarterBuildings();
    }
  }

  function placeStarterBuildings(){
    // ensure starter zone is buildable
    const bx=state.baseTerritory.x;
    const by=state.baseTerritory.y;

    // clear water around base
    for(let y=-2;y<=2;y++){
      for(let x=-2;x<=2;x++){
        const px=bx+x, py=by+y;
        if(px>=0&&py>=0&&px<MAP_W&&py<MAP_H){
          if(state.map[py][px].t===TILE_TYPES.water){
            state.map[py][px].t = TILE_TYPES.grass;
          }
        }
      }
    }

    // give 2 houses + 1 farm at start
    state.map[by][bx].b="house";
    state.map[by][bx].lv=1;

    if(state.map[by][bx+1]) state.map[by][bx+1].b="house";
    if(state.map[by+1] && state.map[by+1][bx]) state.map[by+1][bx].b="farm";

    state.buildingsCount.house = 2;
    state.buildingsCount.farm = 1;
    state.pop = 4;
    state.land = 12;
  }

  // ===============================
  // UI UPDATE
  // ===============================
  function fmt(n){
    if(n>=1000000) return (n/1000000).toFixed(2)+"M";
    if(n>=10000) return (n/1000).toFixed(1)+"K";
    return Math.floor(n).toString();
  }

  function updateUI(){
    coinText.textContent = fmt(state.coin);
    aenoText.textContent = state.aeno.toFixed(4);

    woodText.textContent = fmt(state.wood);
    stoneText.textContent = fmt(state.stone);
    ironText.textContent = fmt(state.iron);
    foodText.textContent = fmt(state.food);

    popText.textContent = state.pop;
    landText.textContent = state.land;
    yearText.textContent = Math.floor(state.year);
  }

  // ===============================
  // PANEL TOGGLE + DRAG
  // ===============================
  let panelOpen = true;

  btnPanel.onclick = () => {
    panelOpen = !panelOpen;
    panel.style.display = panelOpen ? "block" : "none";
  };

  // draggable
  let drag = {on:false, sx:0, sy:0, px:0, py:0};

  function pointerPos(e){
    if(e.touches && e.touches[0]){
      return {x:e.touches[0].clientX, y:e.touches[0].clientY};
    }
    return {x:e.clientX, y:e.clientY};
  }

  panelHeader.addEventListener("pointerdown",(e)=>{
    drag.on=true;
    const p=pointerPos(e);
    drag.sx=p.x; drag.sy=p.y;
    const rect=panel.getBoundingClientRect();
    drag.px=rect.left;
    drag.py=rect.top;
    panelHeader.setPointerCapture(e.pointerId);
  });

  panelHeader.addEventListener("pointermove",(e)=>{
    if(!drag.on) return;
    const p=pointerPos(e);
    const dx=p.x-drag.sx;
    const dy=p.y-drag.sy;

    let nx = drag.px + dx;
    let ny = drag.py + dy;

    nx = clamp(nx, 6, window.innerWidth - panel.offsetWidth - 6);
    ny = clamp(ny, 60, window.innerHeight - panel.offsetHeight - 90);

    panel.style.left = nx+"px";
    panel.style.top = ny+"px";
    panel.style.bottom = "auto";
  });

  panelHeader.addEventListener("pointerup",()=>{
    drag.on=false;
  });

  // ===============================
  // ZOOM BUTTONS
  // ===============================
  btnZoomIn.onclick = () => {
    zoom = clamp(zoom + 0.12, ZOOM_MIN, ZOOM_MAX);
  };
  btnZoomOut.onclick = () => {
    zoom = clamp(zoom - 0.12, ZOOM_MIN, ZOOM_MAX);
  };

  // ===============================
  // CHAT SYSTEM
  // ===============================
  function addChat(role, text){
    const div = document.createElement("div");
    div.className = "msg " + (role==="ai" ? "ai":"you");
    div.textContent = text;
    chatLog.appendChild(div);
    chatLog.scrollTop = chatLog.scrollHeight;
  }

  function openChat(){
    chatBox.style.display = "block";
    if(chatLog.children.length===0){
      addChat("ai","æˆ‘ä¿‚ AENO å°åŠ©æ‰‹ ğŸ¾\nä½ å¯ä»¥æ‰“ï¼šå·¡é‚ / æ”¶é›† / å»ºé€  / å‡ç´š / å„ªå…ˆæœ¨æ / å„ªå…ˆé£Ÿç‰©");
      addChat("ai","æç¤ºï¼šé»åœ°åœ–ç©ºåœ°å¯ä»¥èµ·å»ºç¯‰ã€‚");
    }
  }

  function closeChat(){
    chatBox.style.display = "none";
  }

  chatClose.onclick = closeChat;

  chatSend.onclick = () => {
    const text = chatInput.value.trim();
    if(!text) return;
    chatInput.value = "";
    addChat("you", text);
    parseCommand(text);
  };

  chatInput.addEventListener("keydown",(e)=>{
    if(e.key==="Enter") chatSend.click();
  });

  function parseCommand(text){
    const t = text.toLowerCase();

    if(t.includes("å·¡é‚")){
      addChat("ai","æ”¶åˆ°ï¼å·¥äººæœƒå·¡é‚é ˜åœ°ï¼Œå¢åŠ å®‰å…¨èˆ‡æ¢ç´¢ã€‚");
      state.activeScore += 1.2;
      state.ecoScore += 0.8;
      return;
    }

    if(t.includes("æ”¶é›†")){
      addChat("ai","æ”¶åˆ°ï¼å·¥äººæœƒåŠ é€Ÿæ”¶é›†æœ¨æ/é£Ÿç‰©ã€‚");
      state.ecoScore += 1.6;
      state.wood += 12;
      state.food += 10;
      return;
    }

    if(t.includes("å»ºé€ ")){
      addChat("ai","æ˜ç™½ï¼æˆ‘æœƒå˜—è©¦è‡ªå‹•å»ºç¯‰ã€‚");
      state.autoAI = true;
      return;
    }

    if(t.includes("å‡ç´š")){
      addChat("ai","å‡ç´šç³»çµ±æº–å‚™ä¸­ï¼Œç›®å‰æœƒå„ªå…ˆæ“´å¼µèˆ‡å»ºé€ ã€‚");
      state.buildScore += 1.0;
      return;
    }

    if(t.includes("æœ¨")){
      state.aiPriority = "wood";
      addChat("ai","å·²è¨­å®šï¼šå„ªå…ˆæœ¨æ ğŸŒ²");
      return;
    }

    if(t.includes("çŸ³")){
      state.aiPriority = "stone";
      addChat("ai","å·²è¨­å®šï¼šå„ªå…ˆçŸ³é ­ ğŸª¨");
      return;
    }

    if(t.includes("éµ")){
      state.aiPriority = "iron";
      addChat("ai","å·²è¨­å®šï¼šå„ªå…ˆéµç¤¦ â›ï¸");
      return;
    }

    if(t.includes("é£Ÿ")){
      state.aiPriority = "food";
      addChat("ai","å·²è¨­å®šï¼šå„ªå…ˆé£Ÿç‰© ğŸŒ¾");
      return;
    }

    addChat("ai","æˆ‘è½å””æ˜ï¼Œä½†æˆ‘æœƒç¹¼çºŒå¹«ä½ è‡ªå‹•æ”¶è³‡æºåŒå»ºé€ ã€‚");
  }

  // ===============================
  // PANEL BUTTONS
  // ===============================
  btnAutoOn.onclick = () => {
    state.autoAI = true;
    showToast("AI è‡ªå‹•å»ºé€ ï¼šé–‹");
  };
  btnAutoOff.onclick = () => {
    state.autoAI = false;
    showToast("AI è‡ªå‹•å»ºé€ ï¼šé—œï¼ˆä»æœƒæ”¶è³‡æºï¼‰");
  };

  btnPriorityWood.onclick = () => { state.aiPriority="wood"; showToast("å„ªå…ˆï¼šæœ¨æ"); };
  btnPriorityStone.onclick = () => { state.aiPriority="stone"; showToast("å„ªå…ˆï¼šçŸ³é ­"); };
  btnPriorityIron.onclick = () => { state.aiPriority="iron"; showToast("å„ªå…ˆï¼šéµç¤¦"); };
  btnPriorityFood.onclick = () => { state.aiPriority="food"; showToast("å„ªå…ˆï¼šé£Ÿç‰©"); };

  btnRobotSend.onclick = () => {
    state.robotTrips++;
    state.coin += 30;
    state.wood += randi(10,30);
    state.stone += randi(6,20);
    if(Math.random()<0.55) state.iron += randi(2,6);

    state.ecoScore += 3;
    state.activeScore += 1;

    showToast("æ©Ÿå™¨äººå‡ºç™¼æˆåŠŸï¼å¸¶å›è³‡æº");
  };

  // ad song simulation
  let audioCtx = null;
  btnAdSong.onclick = async () => {
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();

      o.type = "sine";
      o.frequency.value = 440;

      g.gain.value = 0.03;

      o.connect(g);
      g.connect(audioCtx.destination);

      o.start();

      setTimeout(()=>{ o.stop(); }, 650);

      state.adPlayCount++;
      state.adScore += 6.5;
      state.activeScore += 0.6;

      showToast("ğŸµ æ’­æ”¾å®Œæˆï¼ˆå»£å‘Šåˆ†æ•¸ +ï¼‰");
    }catch(e){
      showToast("éŸ³æ•ˆè¢«ç€è¦½å™¨é˜»æ“‹ï¼ˆè«‹å…ˆé»ä¸€ä¸‹ç•«é¢ï¼‰", 2000);
    }
  };

  btnMarket.onclick = () => {
    showToast("äº¤æ˜“æ‰€ï¼šä¸‹ä¸€éšæ®µå•Ÿç”¨ï¼ˆå·²é ç•™ï¼‰", 1600);
    state.ecoScore += 0.4;
  };

  btnTech.onclick = () => {
    showToast("ç§‘æŠ€æ¨¹ï¼šä¸‹ä¸€éšæ®µå•Ÿç”¨ï¼ˆå·²é ç•™ï¼‰", 1600);
    state.buildScore += 0.4;
  };

  // ===============================
  // CAMERA DRAG (MAP)
  // ===============================
  let camDrag = {on:false, sx:0, sy:0, cx:0, cy:0};

  canvas.addEventListener("pointerdown",(e)=>{
    const rect = canvas.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;

    // detect assistant click
    const ap = tileToScreen(assistant.x, assistant.y);
    const ax = (ap.x*zoom + camX);
    const ay = (ap.y*zoom + camY);

    const dist = Math.hypot((px-ax),(py-ay));
    if(dist < 40){
      openChat();
      return;
    }

    // build click
    const t = screenToTile(px,py);
    if(t.tx>=0 && t.ty>=0 && t.tx<MAP_W && t.ty<MAP_H){
      const cell = state.map[t.ty][t.tx];
      if(inTerritory(t.tx,t.ty) && !cell.b && cell.t!==TILE_TYPES.water){
        openBuildPopup(t.tx,t.ty);
        return;
      }
    }

    // else drag camera
    camDrag.on = true;
    camDrag.sx = e.clientX;
    camDrag.sy = e.clientY;
    camDrag.cx = camX;
    camDrag.cy = camY;
    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener("pointermove",(e)=>{
    if(!camDrag.on) return;
    const dx = e.clientX - camDrag.sx;
    const dy = e.clientY - camDrag.sy;
    camX = camDrag.cx + dx;
    camY = camDrag.cy + dy;
  });

  canvas.addEventListener("pointerup",()=>{
    camDrag.on = false;
  });

  // ===============================
  // UPDATE ENTITIES
  // ===============================
  function moveEntity(ent, dt, speedScale=1){
    const dx = ent.tx - ent.x;
    const dy = ent.ty - ent.y;
    const d = Math.hypot(dx,dy);
    if(d < 0.05){
      ent.tx = ent.x + rand(-2.2, 2.2);
      ent.ty = ent.y + rand(-2.2, 2.2);
      ent.tx = clamp(ent.tx, 1, MAP_W-2);
      ent.ty = clamp(ent.ty, 1, MAP_H-2);
      return;
    }
    const sp = (ent.speed||0.5) * dt * speedScale;
    ent.x += (dx/d) * sp;
    ent.y += (dy/d) * sp;
  }

  function updateEntities(dt){
    // workers
    for(const w of workers){
      moveEntity(w, dt, 1.0);
    }

    // animals
    for(const a of animals){
      moveEntity(a, dt, 0.7);
      a.wobble += dt*2;
    }

    // assistant
    assistant.flagWave += dt*2.2;
    assistant.mood += dt*0.2;

    if(Math.random() < 0.01){
      assistant.tx = state.baseTerritory.x + rand(-1.4, 1.4);
      assistant.ty = state.baseTerritory.y + rand(-1.2, 1.2);
    }
    moveEntity(assistant, dt, 0.9);
  }

  // ===============================
  // DRAW WORLD
  // ===============================
  function drawTile(x,y,cell){
    const p = tileToScreen(x,y);
    const sx = p.x*zoom + camX;
    const sy = p.y*zoom + camY;

    const size = TILE*zoom;

    // skip offscreen
    if(sx < -size || sy < -size || sx > innerWidth+size || sy > innerHeight+size) return;

    // base
    let col = "#1f6b3d";
    if(cell.t===TILE_TYPES.grass) col="#1f6b3d";
    if(cell.t===TILE_TYPES.forest) col="#166534";
    if(cell.t===TILE_TYPES.rock) col="#475569";
    if(cell.t===TILE_TYPES.iron) col="#334155";
    if(cell.t===TILE_TYPES.water) col="#0ea5e9";
    if(cell.t===TILE_TYPES.sand) col="#d4b56d";

    ctx.fillStyle = col;
    ctx.fillRect(sx, sy, size, size);

    // tile detail
    if(cell.t===TILE_TYPES.forest){
      ctx.fillStyle="rgba(255,255,255,.08)";
      ctx.beginPath();
      ctx.arc(sx+size*0.35, sy+size*0.35, size*0.14, 0, Math.PI*2);
      ctx.fill();
    }

    if(cell.t===TILE_TYPES.rock){
      ctx.fillStyle="rgba(255,255,255,.08)";
      ctx.fillRect(sx+size*0.15, sy+size*0.15, size*0.25, size*0.25);
    }

    if(cell.t===TILE_TYPES.iron){
      ctx.fillStyle="rgba(96,165,250,.22)";
      ctx.beginPath();
      ctx.arc(sx+size*0.65, sy+size*0.45, size*0.12, 0, Math.PI*2);
      ctx.fill();
    }

    // territory highlight
    if(inTerritory(x,y)){
      ctx.strokeStyle="rgba(96,165,250,.16)";
      ctx.lineWidth=2;
      ctx.strokeRect(sx+1, sy+1, size-2, size-2);
    }

    // building
    if(cell.b){
      drawBuilding(sx,sy,size,cell.b,cell.lv);
    }

    // grid faint
    ctx.strokeStyle="rgba(148,163,184,.05)";
    ctx.lineWidth=1;
    ctx.strokeRect(sx,sy,size,size);
  }

  function drawBuilding(sx,sy,size,type,lv){
    // shadow
    drawShadowCircle(sx+size*0.5, sy+size*0.78, size*0.32, size*0.14, 0.20);

    if(type==="house"){
      // cute house
      ctx.fillStyle="#fde68a";
      roundedRectPath(sx+size*0.18, sy+size*0.34, size*0.64, size*0.42, size*0.12);
      ctx.fill();

      ctx.fillStyle="#f59e0b";
      ctx.beginPath();
      ctx.moveTo(sx+size*0.14, sy+size*0.36);
      ctx.lineTo(sx+size*0.50, sy+size*0.16);
      ctx.lineTo(sx+size*0.86, sy+size*0.36);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle="#92400e";
      roundedRectPath(sx+size*0.45, sy+size*0.55, size*0.12, size*0.22, size*0.05);
      ctx.fill();

      ctx.fillStyle="#93c5fd";
      ctx.beginPath();
      ctx.arc(sx+size*0.32, sy+size*0.55, size*0.06, 0, Math.PI*2);
      ctx.arc(sx+size*0.68, sy+size*0.55, size*0.06, 0, Math.PI*2);
      ctx.fill();
    }

    if(type==="farm"){
      ctx.fillStyle="#a16207";
      roundedRectPath(sx+size*0.14, sy+size*0.36, size*0.72, size*0.44, size*0.12);
      ctx.fill();

      ctx.strokeStyle="rgba(255,255,255,.16)";
      ctx.lineWidth=2;
      for(let i=0;i<4;i++){
        ctx.beginPath();
        ctx.moveTo(sx+size*0.18, sy+size*(0.42+i*0.09));
        ctx.lineTo(sx+size*0.82, sy+size*(0.42+i*0.09));
        ctx.stroke();
      }

      ctx.fillStyle="#22c55e";
      ctx.beginPath();
      ctx.arc(sx+size*0.26, sy+size*0.30, size*0.08, 0, Math.PI*2);
      ctx.arc(sx+size*0.40, sy+size*0.26, size*0.08, 0, Math.PI*2);
      ctx.arc(sx+size*0.56, sy+size*0.30, size*0.08, 0, Math.PI*2);
      ctx.fill();
    }

    if(type==="lumber"){
      ctx.fillStyle="#fef3c7";
      roundedRectPath(sx+size*0.18, sy+size*0.38, size*0.64, size*0.40, size*0.12);
      ctx.fill();

      ctx.fillStyle="#16a34a";
      ctx.beginPath();
      ctx.arc(sx+size*0.30, sy+size*0.40, size*0.14, 0, Math.PI*2);
      ctx.arc(sx+size*0.50, sy+size*0.32, size*0.16, 0, Math.PI*2);
      ctx.arc(sx+size*0.70, sy+size*0.40, size*0.14, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle="#92400e";
      ctx.fillRect(sx+size*0.47, sy+size*0.55, size*0.06, size*0.18);
    }

    if(type==="quarry"){
      ctx.fillStyle="#cbd5e1";
      roundedRectPath(sx+size*0.18, sy+size*0.38, size*0.64, size*0.40, size*0.12);
      ctx.fill();

      ctx.fillStyle="rgba(0,0,0,.2)";
      ctx.beginPath();
      ctx.arc(sx+size*0.42, sy+size*0.55, size*0.12, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle="#64748b";
      ctx.beginPath();
      ctx.arc(sx+size*0.62, sy+size*0.62, size*0.10, 0, Math.PI*2);
      ctx.fill();
    }

    if(type==="mine"){
      ctx.fillStyle="#94a3b8";
      roundedRectPath(sx+size*0.18, sy+size*0.40, size*0.64, size*0.38, size*0.12);
      ctx.fill();

      ctx.fillStyle="#0f172a";
      ctx.beginPath();
      ctx.arc(sx+size*0.50, sy+size*0.60, size*0.16, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle="rgba(96,165,250,.25)";
      ctx.beginPath();
      ctx.arc(sx+size*0.56, sy+size*0.58, size*0.06, 0, Math.PI*2);
      ctx.fill();
    }

    if(type==="factory"){
      ctx.fillStyle="#e2e8f0";
      roundedRectPath(sx+size*0.14, sy+size*0.40, size*0.72, size*0.38, size*0.12);
      ctx.fill();

      ctx.fillStyle="#64748b";
      ctx.fillRect(sx+size*0.20, sy+size*0.28, size*0.12, size*0.18);
      ctx.fillRect(sx+size*0.38, sy+size*0.24, size*0.12, size*0.22);

      ctx.fillStyle="#f97316";
      ctx.fillRect(sx+size*0.62, sy+size*0.26, size*0.10, size*0.28);

      ctx.fillStyle="#93c5fd";
      ctx.fillRect(sx+size*0.26, sy+size*0.52, size*0.12, size*0.10);
      ctx.fillRect(sx+size*0.44, sy+size*0.52, size*0.12, size*0.10);
    }

    // level badge
    ctx.fillStyle="rgba(2,6,23,.55)";
    ctx.beginPath();
    ctx.arc(sx+size*0.82, sy+size*0.26, size*0.10, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle="#fff";
    ctx.font = `${Math.max(10, size*0.18)}px system-ui`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText(String(lv||1), sx+size*0.82, sy+size*0.26);
  }

  function drawWorker(w){
    const p = tileToScreen(w.x, w.y);
    const sx = p.x*zoom + camX;
    const sy = p.y*zoom + camY;
    const size = 16*zoom;

    drawShadowCircle(sx, sy+size*0.7, size*0.8, size*0.35, 0.22);

    ctx.fillStyle="#fde68a";
    ctx.beginPath();
    ctx.arc(sx, sy, size*0.55, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle="#0f172a";
    ctx.beginPath();
    ctx.arc(sx-size*0.18, sy-size*0.05, size*0.07, 0, Math.PI*2);
    ctx.arc(sx+size*0.18, sy-size*0.05, size*0.07, 0, Math.PI*2);
    ctx.fill();

    ctx.strokeStyle="#0f172a";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(sx, sy+size*0.12, size*0.18, 0, Math.PI);
    ctx.stroke();
  }

  function drawAnimal(a){
    const p = tileToScreen(a.x, a.y);
    const sx = p.x*zoom + camX;
    const sy = p.y*zoom + camY;
    const size = 14*zoom;

    drawShadowCircle(sx, sy+size*0.7, size*0.8, size*0.35, 0.18);

    ctx.fillStyle = a.type==="boar" ? "#a16207" : "#f97316";
    ctx.beginPath();
    ctx.arc(sx, sy, size*0.55, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle="rgba(255,255,255,.22)";
    ctx.beginPath();
    ctx.arc(sx-size*0.12, sy-size*0.15, size*0.18, 0, Math.PI*2);
    ctx.fill();
  }

  function drawAssistant(){
    const p = tileToScreen(assistant.x, assistant.y);
    const sx = p.x*zoom + camX;
    const sy = p.y*zoom + camY;
    const size = 18*zoom;

    drawShadowCircle(sx, sy+size*0.8, size*0.95, size*0.40, 0.22);

    // body
    ctx.fillStyle="#60a5fa";
    ctx.beginPath();
    ctx.arc(sx, sy, size*0.62, 0, Math.PI*2);
    ctx.fill();

    // face
    ctx.fillStyle="#e0f2fe";
    ctx.beginPath();
    ctx.arc(sx, sy+size*0.10, size*0.42, 0, Math.PI*2);
    ctx.fill();

    // eyes
    ctx.fillStyle="#0f172a";
    ctx.beginPath();
    ctx.arc(sx-size*0.15, sy, size*0.08, 0, Math.PI*2);
    ctx.arc(sx+size*0.15, sy, size*0.08, 0, Math.PI*2);
    ctx.fill();

    // smile
    ctx.strokeStyle="#0f172a";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(sx, sy+size*0.18, size*0.18, 0, Math.PI);
    ctx.stroke();

    // ad flag
    const wave = Math.sin(assistant.flagWave)*3;
    ctx.strokeStyle="rgba(255,255,255,.6)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(sx+size*0.55, sy-size*0.70);
    ctx.lineTo(sx+size*0.55, sy-size*1.25);
    ctx.stroke();

    ctx.fillStyle="rgba(251,191,36,.95)";
    ctx.beginPath();
    ctx.moveTo(sx+size*0.55, sy-size*1.25);
    ctx.lineTo(sx+size*1.05+wave, sy-size*1.10);
    ctx.lineTo(sx+size*0.55, sy-size*0.95);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle="rgba(2,6,23,.75)";
    ctx.font = `${Math.max(9, size*0.20)}px system-ui`;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.fillText("AD", sx+size*0.82+wave*0.2, sy-size*1.10);
  }

  // ===============================
  // MAIN DRAW
  // ===============================
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // background fog
    ctx.fillStyle="#0b1220";
    ctx.fillRect(0,0,innerWidth,innerHeight);

    // world
    for(let y=0;y<MAP_H;y++){
      for(let x=0;x<MAP_W;x++){
        drawTile(x,y,state.map[y][x]);
      }
    }

    // animals behind
    for(const a of animals) drawAnimal(a);

    // workers
    for(const w of workers) drawWorker(w);

    // assistant top
    drawAssistant();

    // top label
    ctx.fillStyle="rgba(255,255,255,.12)";
    ctx.font="12px system-ui";
    ctx.textAlign="left";
    ctx.textBaseline="top";
    ctx.fillText("AENO V3 - ç›´å±æ–‡æ˜è’é‡ï¼ˆé»ç©ºåœ°å»ºç¯‰ï½œé»åŠ©æ‰‹å°è©±ï¼‰", 10, 60);
  }

  // ===============================
  // GAME LOOP
  // ===============================
  let lastFrame = now();

  function tick(){
    const t = now();
    const dtSec = Math.min(0.05, (t-lastFrame)/1000);
    lastFrame = t;

    // in-game time
    const dtDays = (dtSec / (60*60*24)) * GAME_TIME_SPEED;

    // year update
    state.year += dtDays;

    // activity score
    state.activeScore += dtDays*0.12;

    // production
    productionTick(dtDays);

    // territory expand
    territoryTick(dtDays);

    // beast
    beastTick(dtDays);

    // aeno mint
    calcAenoMint(dtDays);

    // ai build tick slow
    if(Math.random() < 0.02){
      aiBuildTick(dtDays);
    }

    // entities
    updateEntities(dtSec);

    // UI
    updateUI();

    // render
    draw();

    // autosave
    if(now() - state.lastSave > 12000){
      saveGame();
    }

    requestAnimationFrame(tick);
  }

  // ===============================
  // INIT
  // ===============================
  function init(){
    loadGame();
    simulateOffline();

    // set camera to center
    const center = tileToScreen(state.baseTerritory.x, state.baseTerritory.y);
    camX = innerWidth*0.5 - center.x*zoom;
    camY = innerHeight*0.55 - center.y*zoom;

    // ensure worker/animals exist
    if(workers.length===0) spawnWorkers();
    if(animals.length===0) spawnAnimals();

    updateUI();
    showToast("è¼‰å…¥å®Œæˆï½œé»ç©ºåœ°èµ·å»ºç¯‰ï½œé»åŠ©æ‰‹é–‹å°è©±", 2200);

    tick();
  }

  init();

  // safety save
  setInterval(saveGame, 15000);

})();
</script>
</body>
</html>
