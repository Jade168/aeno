<!DOCTYPE html>
<html lang="zh-HK">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>AENO V3 (Mobile Cartoon - Canvas)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0b1020;
      overflow: hidden;
      font-family: Arial, "Microsoft JhengHei", "PingFang HK", sans-serif;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(#091224, #081018);
    }

    /* Small HUD top */
    #hudTop {
      position: fixed;
      top: 6px;
      left: 6px;
      right: 6px;
      display: flex;
      gap: 6px;
      justify-content: space-between;
      z-index: 50;
      pointer-events: none;
    }
    .hudBox {
      pointer-events: auto;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.15);
      color: #fff;
      padding: 6px 8px;
      border-radius: 10px;
      font-size: 11px;
      line-height: 1.25em;
      backdrop-filter: blur(6px);
      max-width: 48vw;
      box-shadow: 0 8px 20px rgba(0,0,0,0.25);
    }
    .hudRow {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .pill {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 11px;
      white-space: nowrap;
    }

    /* Panel */
    #panel {
      position: fixed;
      right: 8px;
      bottom: 80px; /* avoid mobile nav bar */
      width: min(320px, 75vw);
      max-height: 25vh; /* <= 1/4 screen */
      background: rgba(10,14,20,0.85);
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 14px;
      color: #fff;
      z-index: 100;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      touch-action: none;
    }

    #panelHeader {
      padding: 8px 10px;
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255,255,255,0.06);
      cursor: grab;
    }
    #panelHeader:active { cursor: grabbing; }

    #panelBody {
      padding: 8px 10px;
      overflow: auto;
      font-size: 11px;
    }

    .btnRow {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }
    button {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.18);
      color: #fff;
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 11px;
      cursor: pointer;
    }
    button:active { transform: scale(0.98); }

    #togglePanelBtn {
      position: fixed;
      right: 8px;
      bottom: 12px;
      z-index: 200;
      border-radius: 999px;
      padding: 10px 12px;
      font-size: 12px;
      background: rgba(0,0,0,0.6);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(8px);
      color: #fff;
    }

    /* Build Menu popup */
    #buildMenu {
      position: fixed;
      left: 50%;
      top: 55%;
      transform: translate(-50%, -50%);
      width: min(360px, 92vw);
      max-height: 55vh;
      background: rgba(0,0,0,0.82);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 16px;
      color: #fff;
      z-index: 300;
      display: none;
      overflow: hidden;
      box-shadow: 0 15px 40px rgba(0,0,0,0.45);
      backdrop-filter: blur(10px);
    }
    #buildMenuHeader {
      padding: 10px;
      font-size: 13px;
      background: rgba(255,255,255,0.06);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #buildMenuBody {
      padding: 10px;
      overflow: auto;
      font-size: 11px;
    }
    .buildItem {
      padding: 8px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      margin-bottom: 8px;
      background: rgba(255,255,255,0.04);
    }
    .buildItemTitle {
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .buildCost {
      opacity: 0.9;
      margin-bottom: 6px;
    }

    /* Chat bubble */
    #assistantChat {
      position: fixed;
      left: 10px;
      bottom: 85px;
      width: min(320px, 80vw);
      max-height: 22vh;
      background: rgba(0,0,0,0.72);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      color: #fff;
      z-index: 250;
      overflow: hidden;
      display: none;
      backdrop-filter: blur(10px);
      box-shadow: 0 12px 30px rgba(0,0,0,0.4);
    }
    #assistantChatHeader {
      padding: 8px 10px;
      font-size: 12px;
      background: rgba(255,255,255,0.06);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #assistantChatBody {
      padding: 8px 10px;
      font-size: 11px;
      overflow: auto;
      max-height: 12vh;
    }
    #assistantChatInputRow {
      display: flex;
      gap: 6px;
      padding: 8px 10px;
      border-top: 1px solid rgba(255,255,255,0.12);
    }
    #assistantInput {
      flex: 1;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: #fff;
      padding: 6px 8px;
      font-size: 12px;
      outline: none;
    }

    /* Planet select */
    #planetSelect {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.82);
      z-index: 999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: #fff;
      padding: 16px;
      backdrop-filter: blur(10px);
    }
    .planetCard {
      width: min(380px, 92vw);
      padding: 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.06);
      margin-bottom: 10px;
    }
    .planetTitle {
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 6px;
    }
    .planetDesc {
      font-size: 11px;
      opacity: 0.9;
      margin-bottom: 8px;
    }

    /* tiny helper */
    .muted { opacity: 0.85; font-size: 10px; }
    .danger { color: #ff9aa2; }
    .ok { color: #a8ffb8; }
  </style>
</head>

<body>
  <canvas id="game"></canvas>

  <div id="hudTop">
    <div class="hudBox" id="hudLeft">
      <div class="hudRow">
        <span class="pill">ğŸŒ <span id="planetName">?</span></span>
        <span class="pill">â±ï¸ <span id="gameYear">0</span> å¹´</span>
        <span class="pill">ğŸ‘¥ <span id="popCount">0</span></span>
      </div>
      <div class="hudRow" style="margin-top:4px;">
        <span class="pill">ğŸª™ é‡‘å¹£: <span id="coins">0</span></span>
        <span class="pill">ğŸŸ¡ AENO: <span id="aeno">0.0000</span></span>
      </div>
    </div>

    <div class="hudBox" id="hudRight">
      <div class="hudRow">
        <span class="pill">ğŸªµ æœ¨: <span id="wood">0</span></span>
        <span class="pill">ğŸª¨ çŸ³: <span id="stone">0</span></span>
        <span class="pill">â›ï¸ éµ: <span id="iron">0</span></span>
        <span class="pill">ğŸŒ¾ ç³§: <span id="food">0</span></span>
      </div>
      <div class="hudRow" style="margin-top:4px;">
        <span class="pill">âš™ï¸ å·¥å» : <span id="factoryCount">0</span></span>
        <span class="pill">ğŸ¤– æ©Ÿå™¨äºº: <span id="robotCount">0</span></span>
      </div>
    </div>
  </div>

  <button id="togglePanelBtn">ğŸ“Œ é¢æ¿</button>

  <div id="panel">
    <div id="panelHeader">
      <span>ğŸ“Œ æ§åˆ¶ä¸­å¿ƒ</span>
      <span>
        <button id="btnSave">ä¿å­˜</button>
        <button id="btnHidePanel">æ”¶èµ·</button>
      </span>
    </div>
    <div id="panelBody">
      <div><b>æç¤ºï¼š</b>é»ä½ é ˜åœŸç©ºåœ°å¯ä»¥å»ºç¯‰ã€‚</div>
      <div class="muted">Zoom: é›™æŒ‡ç¸®æ”¾ / æ»¾è¼ªã€‚æ‹–åœ°åœ–ï¼šä¸€æŒ‡æ‹–ã€‚</div>

      <div class="btnRow">
        <button id="btnBuildMode">ğŸ—ï¸ å»ºç¯‰æ¨¡å¼</button>
        <button id="btnUpgradeMode">â¬†ï¸ å‡ç´šæ¨¡å¼</button>
        <button id="btnAuto">ğŸ¤– è‡ªå‹•å»ºé€ : <span id="autoState">ON</span></button>
      </div>

      <div class="btnRow">
        <button id="btnAdSong">ğŸµ æ’­æ”¾å»£å‘Šæ­Œ</button>
        <button id="btnLoopSong">ğŸ” Loop: <span id="loopState">ON</span></button>
      </div>

      <div class="btnRow">
        <button id="btnRobotSend">ğŸš€ æ´¾æ©Ÿå™¨äººæ¢ç´¢</button>
        <button id="btnExchange">ğŸ¦ äº¤æ˜“æ‰€</button>
        <button id="btnTech">ğŸ§¬ ç§‘æŠ€æ¨¹</button>
      </div>

      <div style="margin-top:10px;">
        <b>AIåŠ©æ‰‹å„ªå…ˆé †åºï¼š</b>
        <div class="btnRow">
          <button class="prioBtn" data-prio="house">ğŸ  æˆ¿å±‹</button>
          <button class="prioBtn" data-prio="lumber">ğŸªµ ä¼æœ¨</button>
          <button class="prioBtn" data-prio="mine">â›ï¸ ç¤¦å ´</button>
          <button class="prioBtn" data-prio="farm">ğŸŒ¾ è¾²ç”°</button>
          <button class="prioBtn" data-prio="market">ğŸª å¸‚å ´</button>
        </div>
        <div class="muted">ç›®å‰å„ªå…ˆï¼š<span id="prioNow">ğŸ  æˆ¿å±‹</span></div>
      </div>

      <div style="margin-top:10px;">
        <b>ç³»çµ±è¨Šæ¯ï¼š</b>
        <div id="logBox" style="margin-top:6px; max-height: 8vh; overflow:auto; font-size: 11px; opacity:0.92;"></div>
      </div>
    </div>
  </div>

  <div id="buildMenu">
    <div id="buildMenuHeader">
      <span>ğŸ—ï¸ å»ºç¯‰é¸å–®</span>
      <button id="closeBuildMenu">é—œé–‰</button>
    </div>
    <div id="buildMenuBody"></div>
  </div>

  <div id="assistantChat">
    <div id="assistantChatHeader">
      <span>ğŸ¾ AENO AI åŠ©æ‰‹</span>
      <button id="closeChat">æ”¶èµ·</button>
    </div>
    <div id="assistantChatBody"></div>
    <div id="assistantChatInputRow">
      <input id="assistantInput" placeholder="è¼¸å…¥æŒ‡ä»¤ï¼šå·¡é‚ / æ”¶é›† / å»ºé€  / å‡ç´š..." />
      <button id="sendAssistant">é€å‡º</button>
    </div>
  </div>

  <div id="planetSelect">
    <div style="font-size:18px; font-weight:bold; margin-bottom:10px;">ğŸŒŒ AENO V3 é¸æ“‡æ˜Ÿçƒ</div>

    <div class="planetCard">
      <div class="planetTitle">ğŸŸ© Planet-01 ç¶ åŸæ˜Ÿ</div>
      <div class="planetDesc">æ£®æ—å¤šï¼Œé©åˆæ–°æ‰‹ã€‚æœ¨æç”¢å‡ºé«˜ã€‚</div>
      <button onclick="startGame('Planet-01', 'forest')">é€²å…¥</button>
    </div>

    <div class="planetCard">
      <div class="planetTitle">ğŸŸ« Planet-02 å²©çŸ³æ˜Ÿ</div>
      <div class="planetDesc">çŸ³é ­å¤šï¼Œå»ºç¯‰æ›´å¿«ï¼Œåœ°å½¢å´å¶‡ã€‚</div>
      <button onclick="startGame('Planet-02', 'rock')">é€²å…¥</button>
    </div>

    <div class="planetCard">
      <div class="planetTitle">âš™ï¸ Planet-03 å·¥æ¥­æ˜Ÿ</div>
      <div class="planetDesc">éµç¤¦å¤šï¼Œé©åˆæ©Ÿå™¨äººèˆ‡å·¥å» æ–‡æ˜ã€‚</div>
      <button onclick="startGame('Planet-03', 'iron')">é€²å…¥</button>
    </div>

    <div class="planetCard">
      <div class="planetTitle">ğŸŒ¾ Planet-04 è¾²ç‰§æ˜Ÿ</div>
      <div class="planetDesc">ç³§é£Ÿè±å¯Œï¼Œäººå£æˆé•·å¿«ã€‚</div>
      <button onclick="startGame('Planet-04', 'farm')">é€²å…¥</button>
    </div>

    <div class="planetCard" style="border-color: rgba(255,255,255,0.3); background: rgba(80,0,120,0.22);">
      <div class="planetTitle">ğŸ•³ï¸ é»‘æ´å­¤å³¶ï¼ˆDeveloper Islandï¼‰</div>
      <div class="planetDesc">ç‰¹æ®Šæ˜ŸåŸŸã€‚æœªä¾†ç§»æ°‘ç³»çµ±ã€ç”³è«‹åˆ¶åº¦æœƒç”±æ­¤é–‹å§‹ã€‚</div>
      <button onclick="startGame('BlackHole-Island', 'blackhole')">é€²å…¥</button>
    </div>

    <div class="muted" style="margin-top:10px; text-align:center;">
      âš ï¸ éŠæˆ²æœƒè‡ªå‹•ä¿å­˜ã€‚æ›´æ–°ç‰ˆæœ¬å¾Œä»å¯ä¿ç•™é€²åº¦ã€‚<br/>
      éŸ³æ¨‚éœ€æ‰‹å‹•é»æ“Šæ’­æ”¾ï¼ˆæ‰‹æ©Ÿé™åˆ¶ï¼‰ã€‚
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ==========================================================
  // SAFE UTILITIES
  // ==========================================================
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const rand = (a, b) => a + Math.random() * (b - a);
  const irand = (a, b) => Math.floor(rand(a, b + 1));

  function nowMs(){ return Date.now(); }

  function drawRoundedRect(ctx, x, y, w, h, r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // ==========================================================
  // GAME CONSTANTS
  // ==========================================================
  const STORAGE_KEY = "AENO_V3_SAVE_SINGLEFILE_2026";
  const GAME_SPEED_YEAR_PER_REALDAY = 10; // 1 day = 10 years (your requirement)
  const MS_PER_DAY = 24*60*60*1000;

  // offline cap 24h
  const OFFLINE_CAP_MS = 24 * 60 * 60 * 1000;

  // ==========================================================
  // CANVAS SETUP
  // ==========================================================
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  let W = 0, H = 0;
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    W = window.innerWidth;
    H = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  // ==========================================================
  // UI ELEMENTS
  // ==========================================================
  const elPlanetName = document.getElementById("planetName");
  const elGameYear = document.getElementById("gameYear");
  const elPopCount = document.getElementById("popCount");
  const elCoins = document.getElementById("coins");
  const elAeno = document.getElementById("aeno");
  const elWood = document.getElementById("wood");
  const elStone = document.getElementById("stone");
  const elIron = document.getElementById("iron");
  const elFood = document.getElementById("food");
  const elFactoryCount = document.getElementById("factoryCount");
  const elRobotCount = document.getElementById("robotCount");

  const panel = document.getElementById("panel");
  const panelHeader = document.getElementById("panelHeader");
  const panelBody = document.getElementById("panelBody");
  const togglePanelBtn = document.getElementById("togglePanelBtn");

  const btnHidePanel = document.getElementById("btnHidePanel");
  const btnSave = document.getElementById("btnSave");
  const logBox = document.getElementById("logBox");

  const btnBuildMode = document.getElementById("btnBuildMode");
  const btnUpgradeMode = document.getElementById("btnUpgradeMode");
  const btnAuto = document.getElementById("btnAuto");
  const autoState = document.getElementById("autoState");

  const btnAdSong = document.getElementById("btnAdSong");
  const btnLoopSong = document.getElementById("btnLoopSong");
  const loopState = document.getElementById("loopState");

  const btnRobotSend = document.getElementById("btnRobotSend");
  const btnExchange = document.getElementById("btnExchange");
  const btnTech = document.getElementById("btnTech");

  const buildMenu = document.getElementById("buildMenu");
  const buildMenuBody = document.getElementById("buildMenuBody");
  const closeBuildMenu = document.getElementById("closeBuildMenu");

  const assistantChat = document.getElementById("assistantChat");
  const assistantChatBody = document.getElementById("assistantChatBody");
  const closeChat = document.getElementById("closeChat");
  const assistantInput = document.getElementById("assistantInput");
  const sendAssistant = document.getElementById("sendAssistant");

  const prioNow = document.getElementById("prioNow");

  // ==========================================================
  // LOG SYSTEM
  // ==========================================================
  function log(msg, type="") {
    const div = document.createElement("div");
    div.textContent = msg;
    if (type === "danger") div.style.color = "#ff9aa2";
    if (type === "ok") div.style.color = "#a8ffb8";
    logBox.prepend(div);
    while (logBox.children.length > 40) logBox.removeChild(logBox.lastChild);
  }

  // ==========================================================
  // AUDIO (Ad Song)
  // ==========================================================
  // Public domain style generated tone sequence (no copyright song)
  // It's a simple procedural melody using WebAudio (safe).
  let audioCtx = null;
  let isPlayingSong = false;
  let songLoop = true;
  let songTimer = null;

  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  function playAdSong() {
    try {
      ensureAudio();
      if (audioCtx.state === "suspended") audioCtx.resume();

      stopAdSong();

      isPlayingSong = true;
      log("ğŸµ å»£å‘Šæ­Œæ’­æ”¾ä¸­ï¼ˆå¯Loopï¼‰", "ok");

      const base = audioCtx.currentTime;
      const notes = [
        261.63, 293.66, 329.63, 392.00,
        392.00, 329.63, 293.66, 261.63,
        293.66, 329.63, 392.00, 523.25,
        440.00, 392.00, 329.63, 293.66
      ];

      const durationPer = 0.25; // longer than before
      const totalDur = notes.length * durationPer;

      for (let i = 0; i < notes.length; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.type = "triangle";
        osc.frequency.value = notes[i];

        gain.gain.setValueAtTime(0.0001, base + i * durationPer);
        gain.gain.exponentialRampToValueAtTime(0.12, base + i * durationPer + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, base + i * durationPer + durationPer);

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.start(base + i * durationPer);
        osc.stop(base + i * durationPer + durationPer);
      }

      // Loop manually
      if (songLoop) {
        songTimer = setTimeout(() => {
          if (isPlayingSong) playAdSong();
        }, totalDur * 1000);
      }

    } catch(e) {
      log("âš ï¸ æ’­æ”¾éŸ³æ¨‚å¤±æ•—ï¼ˆæ‰‹æ©ŸChromeéœ€é»æ“Šå…è¨±éŸ³è¨Šï¼‰", "danger");
    }
  }

  function stopAdSong() {
    isPlayingSong = false;
    if (songTimer) clearTimeout(songTimer);
    songTimer = null;
  }

  // ==========================================================
  // GAME STATE
  // ==========================================================
  const defaultState = () => ({
    version: 3,
    planet: "Planet-01",
    seedType: "forest",

    lastSaveAt: nowMs(),
    lastTickAt: nowMs(),

    year: 0,

    coins: 2000,
    aeno: 0.0,

    wood: 800,
    stone: 800,
    iron: 800,
    food: 800,

    population: 4,
    workers: 4,
    robots: 0,

    territoryRadius: 140, // visible clear circle
    territoryLevel: 1,

    buildings: [
      { type:"house", x: -40, y: 20, level: 1 },
      { type:"house", x: 40, y: 20, level: 1 },
    ],

    beasts: [],
    animals: [],
    workersUnits: [],
    assistant: { x: 0, y: -40, mood: "happy" },

    camera: { x: 0, y: 0, zoom: 1.0 },

    autoBuild: true,
    buildPriority: "house",

    buildMode: false,
    upgradeMode: false,

    offlineStop: false,

    world: {
      forests: [],
      rocks: [],
      irons: [],
      rivers: [],
      mountains: []
    }
  });

  let state = null;

  function safeLoad() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const data = JSON.parse(raw);
      if (!data || typeof data !== "object") return null;
      return data;
    } catch(e) {
      return null;
    }
  }

  function safeSave() {
    try {
      state.lastSaveAt = nowMs();
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      log("ğŸ’¾ å·²ä¿å­˜é€²åº¦", "ok");
    } catch(e) {
      log("âš ï¸ ä¿å­˜å¤±æ•—ï¼ˆlocalStorageè¢«ç¦ç”¨ï¼‰", "danger");
    }
  }

  function deepMerge(target, source) {
    for (const k in source) {
      if (source[k] && typeof source[k] === "object" && !Array.isArray(source[k])) {
        if (!target[k] || typeof target[k] !== "object") target[k] = {};
        deepMerge(target[k], source[k]);
      } else {
        if (target[k] === undefined) target[k] = source[k];
      }
    }
    return target;
  }

  function ensureWorldGenerated() {
    // Generate world objects if missing
    const w = state.world;
    if (!w.forests || w.forests.length < 15) {
      w.forests = [];
      for (let i=0;i<24;i++) {
        w.forests.push({ x: irand(-900,900), y: irand(-900,900), r: irand(30,80) });
      }
    }
    if (!w.rocks || w.rocks.length < 12) {
      w.rocks = [];
      for (let i=0;i<18;i++) {
        w.rocks.push({ x: irand(-900,900), y: irand(-900,900), r: irand(20,60) });
      }
    }
    if (!w.irons || w.irons.length < 10) {
      w.irons = [];
      for (let i=0;i<14;i++) {
        w.irons.push({ x: irand(-900,900), y: irand(-900,900), r: irand(18,50) });
      }
    }
    if (!w.mountains || w.mountains.length < 10) {
      w.mountains = [];
      for (let i=0;i<16;i++) {
        w.mountains.push({ x: irand(-950,950), y: irand(-950,950), r: irand(40,110) });
      }
    }
    if (!w.rivers || w.rivers.length < 2) {
      w.rivers = [];
      for (let i=0;i<3;i++) {
        w.rivers.push({
          x1: irand(-900,900), y1: irand(-900,900),
          x2: irand(-900,900), y2: irand(-900,900)
        });
      }
    }
  }

  function spawnLife() {
    if (!state.animals || state.animals.length < 10) {
      state.animals = [];
      for (let i=0;i<12;i++) {
        state.animals.push({ x: irand(-500,500), y: irand(-500,500), vx: rand(-0.4,0.4), vy: rand(-0.4,0.4), t: 0 });
      }
    }

    if (!state.beasts || state.beasts.length < 6) {
      state.beasts = [];
      for (let i=0;i<8;i++) {
        state.beasts.push({ x: irand(-650,650), y: irand(-650,650), vx: rand(-0.3,0.3), vy: rand(-0.3,0.3), hp: 100 });
      }
    }

    if (!state.workersUnits || state.workersUnits.length < state.workers) {
      state.workersUnits = [];
      for (let i=0;i<state.workers;i++) {
        state.workersUnits.push({ x: irand(-60,60), y: irand(-60,60), tx: irand(-200,200), ty: irand(-200,200), mode:"idle" });
      }
    }
  }

  // ==========================================================
  // BUILDINGS
  // ==========================================================
  const BUILDINGS = {
    house: {
      name: "æˆ¿å±‹",
      desc: "å¢åŠ äººå£ä¸Šé™èˆ‡ç¨…æ”¶ã€‚",
      baseCost: { coins: 200, wood: 120, stone: 80, iron: 0, food: 0 },
      income: { coins: 2, food: 0, wood: 0, stone: 0, iron: 0 },
    },
    lumber: {
      name: "ä¼æœ¨å ´",
      desc: "ç”¢å‡ºæœ¨æã€‚",
      baseCost: { coins: 250, wood: 80, stone: 50, iron: 0, food: 0 },
      income: { wood: 5 }
    },
    mine: {
      name: "ç¤¦å ´",
      desc: "ç”¢å‡ºçŸ³é ­èˆ‡éµã€‚",
      baseCost: { coins: 350, wood: 60, stone: 120, iron: 0, food: 0 },
      income: { stone: 3, iron: 2 }
    },
    farm: {
      name: "è¾²ç”°",
      desc: "ç”¢å‡ºç³§é£Ÿï¼Œæ”¯æŒäººå£æˆé•·ã€‚",
      baseCost: { coins: 220, wood: 70, stone: 40, iron: 0, food: 0 },
      income: { food: 6 }
    },
    factory: {
      name: "å·¥å» ",
      desc: "ç”Ÿç”¢æ©Ÿå™¨äººç¢ç‰‡èˆ‡å·¥æ¥­ç”¢èƒ½ã€‚",
      baseCost: { coins: 800, wood: 120, stone: 200, iron: 120, food: 0 },
      income: { coins: 4, iron: 1 }
    },
    market: {
      name: "å¸‚å ´",
      desc: "æä¾›é‡‘å¹£æ”¶å…¥ï¼Œæ”¯æ´äº¤æ˜“æ‰€ã€‚",
      baseCost: { coins: 500, wood: 120, stone: 100, iron: 20, food: 0 },
      income: { coins: 8 }
    }
  };

  function buildingCost(type, level) {
    const b = BUILDINGS[type];
    const mul = Math.pow(1.55, level-1);
    return {
      coins: Math.floor((b.baseCost.coins||0) * mul),
      wood: Math.floor((b.baseCost.wood||0) * mul),
      stone: Math.floor((b.baseCost.stone||0) * mul),
      iron: Math.floor((b.baseCost.iron||0) * mul),
      food: Math.floor((b.baseCost.food||0) * mul),
    };
  }

  function canAfford(cost) {
    return state.coins >= cost.coins &&
           state.wood >= cost.wood &&
           state.stone >= cost.stone &&
           state.iron >= cost.iron &&
           state.food >= cost.food;
  }

  function pay(cost) {
    state.coins -= cost.coins;
    state.wood -= cost.wood;
    state.stone -= cost.stone;
    state.iron -= cost.iron;
    state.food -= cost.food;
  }

  function addBuilding(type, x, y) {
    const cost = buildingCost(type, 1);
    if (!canAfford(cost)) {
      log("âŒ è³‡æºä¸è¶³ï¼Œç„¡æ³•å»ºé€  " + BUILDINGS[type].name, "danger");
      return false;
    }

    pay(cost);
    state.buildings.push({ type, x, y, level: 1 });
    log("ğŸ—ï¸ å»ºé€ æˆåŠŸï¼š" + BUILDINGS[type].name, "ok");

    // add population effect
    if (type === "house") {
      state.population += 2;
      state.workers += 1;
      spawnLife();
    }

    return true;
  }

  function upgradeBuildingAt(x, y) {
    const b = findBuildingNear(x, y, 40);
    if (!b) {
      log("â¬†ï¸ é€™è£¡æ²’æœ‰å¯å‡ç´šå»ºç¯‰", "danger");
      return;
    }
    const nextLevel = b.level + 1;
    const cost = buildingCost(b.type, nextLevel);

    if (!canAfford(cost)) {
      log("âŒ å‡ç´šè³‡æºä¸è¶³ï¼š" + BUILDINGS[b.type].name + " Lv." + nextLevel, "danger");
      return;
    }

    pay(cost);
    b.level = nextLevel;
    log("â¬†ï¸ å‡ç´šæˆåŠŸï¼š" + BUILDINGS[b.type].name + " Lv." + b.level, "ok");
  }

  function findBuildingNear(x, y, dist=40) {
    let best = null;
    let bestD = 1e9;
    for (const b of state.buildings) {
      const dx = b.x - x;
      const dy = b.y - y;
      const d = Math.sqrt(dx*dx+dy*dy);
      if (d < dist && d < bestD) {
        bestD = d;
        best = b;
      }
    }
    return best;
  }

  // ==========================================================
  // TERRITORY
  // ==========================================================
  function isInsideTerritory(wx, wy) {
    const r = state.territoryRadius;
    return (wx*wx + wy*wy) <= r*r;
  }

  function expandTerritoryAuto() {
    // expands slowly based on workers activity
    const cost = 120 + state.territoryLevel * 80;
    if (state.coins >= cost) {
      state.coins -= cost;
      state.territoryLevel += 1;
      state.territoryRadius += 25;
      log("ğŸ—ºï¸ é ˜åœŸæ“´å¤§ï¼(Lv." + state.territoryLevel + ")", "ok");
    }
  }

  // ==========================================================
  // AI ASSISTANT
  // ==========================================================
  function assistantSay(msg) {
    const div = document.createElement("div");
    div.textContent = "ğŸ¾ " + msg;
    assistantChatBody.appendChild(div);
    assistantChatBody.scrollTop = assistantChatBody.scrollHeight;
  }

  function handleAssistantCommand(text) {
    const t = text.trim().toLowerCase();
    if (!t) return;

    assistantSay("æ”¶åˆ°æŒ‡ä»¤ï¼šã€Œ" + text + "ã€");

    if (t.includes("å·¡é‚")) {
      assistantSay("æˆ‘æœƒå·¡é‚é ˜åœŸé‚Šç•Œï¼Œé©…è¶•é‡ç¸ã€‚");
      state.assistant.mood = "guard";
    } else if (t.includes("æ”¶é›†")) {
      assistantSay("æˆ‘æœƒæŒ‡æ®å·¥äººåŠ é€Ÿæ”¶é›†è³‡æºã€‚");
      state.assistant.mood = "collect";
    } else if (t.includes("å»ºé€ ")) {
      assistantSay("æˆ‘æœƒé–‹å§‹å»ºé€ å„ªå…ˆå»ºç¯‰ã€‚");
      state.autoBuild = true;
    } else if (t.includes("åœæ­¢") || t.includes("åœ")) {
      assistantSay("å·²åœæ­¢è‡ªå‹•å»ºé€ ã€‚");
      state.autoBuild = false;
    } else if (t.includes("å‡ç´š")) {
      assistantSay("æˆ‘æœƒå„ªå…ˆå‡ç´šé‡è¦å»ºç¯‰ã€‚");
      state.buildPriority = "upgrade";
    } else {
      assistantSay("æˆ‘æ˜ç™½ï¼Œä½†éœ€è¦æ›´æ˜ç¢ºæŒ‡ä»¤ï¼Œä¾‹å¦‚ï¼šå»ºé€  æˆ¿å±‹ / åœæ­¢ / å·¡é‚");
    }
  }

  // ==========================================================
  // AENO PRODUCTION (OBFUSCATED STYLE)
  // ==========================================================
  // You requested to keep AENO algorithm secret.
  // We'll do a simple obfuscation mapping.
  // This is not true security, but prevents easy reading.

  const AENO_MAP = "KLMNOPQRST"; // 10 chars (K=1 ... T=0) just as you described idea
  function secretEncodeDigit(d) {
    if (d === 0) return AENO_MAP[9];
    return AENO_MAP[d-1];
  }
  function secretDecodeChar(c) {
    const idx = AENO_MAP.indexOf(c);
    if (idx === 9) return 0;
    if (idx >= 0) return idx+1;
    return 0;
  }

  function hiddenAenoGainFactor() {
    // A pseudo hidden factor based on time, workers, ad-play, etc.
    // Obfuscated by mapping digits into letters then decoding.
    const base = 1 + (state.population * 0.01) + (state.robots * 0.02);
    const t = Math.floor((nowMs() / 1000) % 10);
    const c = secretEncodeDigit(t);
    const n = secretDecodeChar(c);
    return base * (1 + n * 0.003);
  }

  function gainAenoFragments(seconds, adBoost=false) {
    // fragments to slow down AENO generation
    // base very low
    let rate = 0.0000025; // base per second (slow)
    if (adBoost) rate *= 4.5;
    rate *= hiddenAenoGainFactor();

    // learning bonus: pretend user pronounces resources
    const learningBonus = 1 + (Math.min(1, (state.population / 50)) * 0.35);
    rate *= learningBonus;

    state.aeno += rate * seconds;

    if (state.aeno < 0) state.aeno = 0;
  }

  // ==========================================================
  // ECONOMY TICK
  // ==========================================================
  function buildingIncomePerSecond(b) {
    const def = BUILDINGS[b.type];
    const lvlMul = Math.pow(1.35, b.level-1);
    const income = def.income || {};
    return {
      coins: (income.coins || 0) * lvlMul,
      wood: (income.wood || 0) * lvlMul,
      stone: (income.stone || 0) * lvlMul,
      iron: (income.iron || 0) * lvlMul,
      food: (income.food || 0) * lvlMul
    };
  }

  function tickEconomy(dtSec) {
    let c=0,w=0,s=0,i=0,f=0;
    for (const b of state.buildings) {
      const inc = buildingIncomePerSecond(b);
      c += inc.coins;
      w += inc.wood;
      s += inc.stone;
      i += inc.iron;
      f += inc.food;
    }

    // population tax base (very important for coins)
    c += state.population * 0.08;

    state.coins += c * dtSec;
    state.wood += w * dtSec;
    state.stone += s * dtSec;
    state.iron += i * dtSec;
    state.food += f * dtSec;

    // keep integers for display
    state.coins = Math.floor(state.coins);
    state.wood = Math.floor(state.wood);
    state.stone = Math.floor(state.stone);
    state.iron = Math.floor(state.iron);
    state.food = Math.floor(state.food);

    // year progression
    const yearRate = GAME_SPEED_YEAR_PER_REALDAY / MS_PER_DAY; // years per ms
    const yearAdd = dtSec * 1000 * yearRate;
    state.year += yearAdd;

    // hunger cost
    const foodCost = state.population * 0.02 * dtSec;
    state.food = Math.max(0, state.food - foodCost);

    // AENO only if ad is playing OR learning
    if (isPlayingSong) gainAenoFragments(dtSec, true);
    else gainAenoFragments(dtSec, false);

    // small chance expand territory
    if (Math.random() < dtSec * 0.01) expandTerritoryAuto();
  }

  // ==========================================================
  // AUTOBUILD AI
  // ==========================================================
  function autoBuildTick() {
    if (!state.autoBuild) return;

    // prevent spam building
    if (Math.random() > 0.25) return;

    const pr = state.buildPriority;

    // limit too many buildings early
    const countType = (t) => state.buildings.filter(b=>b.type===t).length;

    let want = pr;

    if (pr === "upgrade") {
      // upgrade lowest level building if possible
      const b = state.buildings.reduce((min, cur) => cur.level < min.level ? cur : min, state.buildings[0]);
      if (b) {
        const cost = buildingCost(b.type, b.level+1);
        if (canAfford(cost)) {
          pay(cost);
          b.level++;
          log("ğŸ¤– åŠ©æ‰‹è‡ªå‹•å‡ç´šï¼š" + BUILDINGS[b.type].name + " Lv." + b.level, "ok");
        }
      }
      return;
    }

    // adaptive fallback
    if (state.food < 200) want = "farm";
    if (state.wood < 200) want = "lumber";
    if (state.stone < 200 || state.iron < 200) want = "mine";
    if (state.coins < 300) want = "market";

    if (countType("house") < 2) want = "house";
    if (countType("farm") < 1) want = "farm";
    if (countType("lumber") < 1) want = "lumber";
    if (countType("mine") < 1) want = "mine";

    const tries = 8;
    for (let t=0;t<tries;t++) {
      const x = irand(-state.territoryRadius+40, state.territoryRadius-40);
      const y = irand(-state.territoryRadius+40, state.territoryRadius-40);
      if (!isInsideTerritory(x,y)) continue;
      if (findBuildingNear(x,y,45)) continue;

      const ok = addBuilding(want, x, y);
      if (ok) return;
    }
  }

  // ==========================================================
  // ROBOT EXPLORE
  // ==========================================================
  function sendRobotExplore() {
    if (state.robots <= 0) {
      log("ğŸ¤– ä½ æ²’æœ‰æ©Ÿå™¨äººï¼ˆéœ€è¦å·¥å» å‡ç´šå¾Œç²å¾—ï¼‰", "danger");
      return;
    }
    log("ğŸš€ æ©Ÿå™¨äººå‡ºç™¼æ¢ç´¢æ˜Ÿçƒ...", "ok");

    // reward
    const gainCoins = irand(60,200);
    const gainRes = irand(30,150);

    state.coins += gainCoins;
    state.wood += gainRes;
    state.stone += gainRes;
    state.iron += Math.floor(gainRes*0.6);

    assistantSay("æ¢ç´¢å®Œæˆï¼ç²å¾—é‡‘å¹£+"+gainCoins+" è³‡æº+"+gainRes);
  }

  // ==========================================================
  // BUILD MENU UI
  // ==========================================================
  let pendingBuildPos = null;

  function openBuildMenu(wx, wy) {
    pendingBuildPos = { x: wx, y: wy };

    buildMenuBody.innerHTML = "";

    for (const key of Object.keys(BUILDINGS)) {
      const def = BUILDINGS[key];
      const cost = buildingCost(key, 1);

      const div = document.createElement("div");
      div.className = "buildItem";
      div.innerHTML = `
        <div class="buildItemTitle">ğŸ—ï¸ ${def.name}</div>
        <div class="muted">${def.desc}</div>
        <div class="buildCost">æˆæœ¬ï¼šğŸª™${cost.coins} ğŸªµ${cost.wood} ğŸª¨${cost.stone} â›ï¸${cost.iron}</div>
        <button data-build="${key}">å»ºé€ </button>
      `;
      buildMenuBody.appendChild(div);
    }

    buildMenu.style.display = "block";

    buildMenuBody.querySelectorAll("button[data-build]").forEach(btn=>{
      btn.addEventListener("click", ()=>{
        const type = btn.getAttribute("data-build");
        if (!pendingBuildPos) return;

        const ok = addBuilding(type, pendingBuildPos.x, pendingBuildPos.y);
        if (ok) {
          buildMenu.style.display = "none";
          pendingBuildPos = null;
        }
      });
    });
  }

  closeBuildMenu.addEventListener("click", ()=>{
    buildMenu.style.display = "none";
    pendingBuildPos = null;
  });

  // ==========================================================
  // PANEL DRAG
  // ==========================================================
  let draggingPanel = false;
  let panelDragOffset = { x:0, y:0 };

  panelHeader.addEventListener("pointerdown", (e)=>{
    draggingPanel = true;
    panelDragOffset.x = e.clientX - panel.offsetLeft;
    panelDragOffset.y = e.clientY - panel.offsetTop;
    panelHeader.setPointerCapture(e.pointerId);
  });

  panelHeader.addEventListener("pointermove", (e)=>{
    if (!draggingPanel) return;
    let nx = e.clientX - panelDragOffset.x;
    let ny = e.clientY - panelDragOffset.y;
    nx = clamp(nx, 4, W - panel.offsetWidth - 4);
    ny = clamp(ny, 4, H - panel.offsetHeight - 60);
    panel.style.left = nx + "px";
    panel.style.top = ny + "px";
    panel.style.right = "auto";
    panel.style.bottom = "auto";
  });

  panelHeader.addEventListener("pointerup", ()=>{
    draggingPanel = false;
  });

  // ==========================================================
  // GAME CAMERA & INPUT
  // ==========================================================
  let pointerDown = false;
  let lastPointer = { x:0, y:0 };

  function screenToWorld(sx, sy) {
    const z = state.camera.zoom;
    const wx = (sx - W/2)/z + state.camera.x;
    const wy = (sy - H/2)/z + state.camera.y;
    return { x: wx, y: wy };
  }

  function worldToScreen(wx, wy) {
    const z = state.camera.zoom;
    const sx = (wx - state.camera.x)*z + W/2;
    const sy = (wy - state.camera.y)*z + H/2;
    return { x: sx, y: sy };
  }

  canvas.addEventListener("pointerdown", (e)=>{
    pointerDown = true;
    lastPointer.x = e.clientX;
    lastPointer.y = e.clientY;
  });

  canvas.addEventListener("pointermove", (e)=>{
    if (!pointerDown) return;
    const dx = e.clientX - lastPointer.x;
    const dy = e.clientY - lastPointer.y;
    lastPointer.x = e.clientX;
    lastPointer.y = e.clientY;

    state.camera.x -= dx / state.camera.zoom;
    state.camera.y -= dy / state.camera.zoom;
  });

  canvas.addEventListener("pointerup", (e)=>{
    pointerDown = false;

    // treat as click if small movement
    const pos = screenToWorld(e.clientX, e.clientY);

    // assistant click detection
    const ax = state.assistant.x;
    const ay = state.assistant.y;
    const distA = Math.sqrt((pos.x-ax)**2 + (pos.y-ay)**2);
    if (distA < 30) {
      assistantChat.style.display = assistantChat.style.display === "none" ? "block" : "none";
      if (assistantChat.style.display === "block") {
        assistantSay("ä½ å¥½ï¼æˆ‘å¯ä»¥å¹«ä½ å»ºé€ ã€å‡ç´šã€æ”¶é›†è³‡æºã€‚");
      }
      return;
    }

    // if upgrade mode
    if (state.upgradeMode) {
      upgradeBuildingAt(pos.x, pos.y);
      return;
    }

    // build mode OR normal tap inside territory
    if (!isInsideTerritory(pos.x, pos.y)) {
      log("âŒ ä¸æ˜¯é ˜åœŸï¼Œç„¡æ³•å»ºç¯‰", "danger");
      return;
    }

    // if click on building -> show info
    const b = findBuildingNear(pos.x, pos.y, 40);
    if (b) {
      log("ğŸ›ï¸ " + BUILDINGS[b.type].name + " Lv." + b.level, "ok");
      return;
    }

    openBuildMenu(pos.x, pos.y);
  });

  canvas.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const dz = (e.deltaY > 0) ? -0.08 : 0.08;
    state.camera.zoom = clamp(state.camera.zoom + dz, 0.6, 2.8);
  }, { passive: false });

  // Touch pinch zoom
  let lastDist = null;
  canvas.addEventListener("touchmove", (e)=>{
    if (e.touches.length === 2) {
      const dx = e.touches[0].clientX - e.touches[1].clientX;
      const dy = e.touches[0].clientY - e.touches[1].clientY;
      const d = Math.sqrt(dx*dx+dy*dy);
      if (lastDist !== null) {
        const diff = d - lastDist;
        state.camera.zoom = clamp(state.camera.zoom + diff * 0.002, 0.6, 2.8);
      }
      lastDist = d;
    }
  }, { passive: true });

  canvas.addEventListener("touchend", ()=>{
    lastDist = null;
  });

  // ==========================================================
  // UI BUTTONS
  // ==========================================================
  btnHidePanel.addEventListener("click", ()=>{
    panel.style.display = "none";
  });

  togglePanelBtn.addEventListener("click", ()=>{
    panel.style.display = panel.style.display === "none" ? "flex" : "none";
  });

  btnSave.addEventListener("click", safeSave);

  btnBuildMode.addEventListener("click", ()=>{
    state.buildMode = true;
    state.upgradeMode = false;
    log("ğŸ—ï¸ å»ºç¯‰æ¨¡å¼ï¼šé»é ˜åœŸç©ºåœ°å»ºé€ ", "ok");
  });

  btnUpgradeMode.addEventListener("click", ()=>{
    state.upgradeMode = true;
    state.buildMode = false;
    log("â¬†ï¸ å‡ç´šæ¨¡å¼ï¼šé»å»ºç¯‰å‡ç´š", "ok");
  });

  btnAuto.addEventListener("click", ()=>{
    state.autoBuild = !state.autoBuild;
    autoState.textContent = state.autoBuild ? "ON" : "OFF";
    log("ğŸ¤– è‡ªå‹•å»ºé€ ï¼š" + (state.autoBuild ? "å•Ÿå‹•" : "åœæ­¢"), "ok");
  });

  btnAdSong.addEventListener("click", ()=>{
    playAdSong();
  });

  btnLoopSong.addEventListener("click", ()=>{
    songLoop = !songLoop;
    loopState.textContent = songLoop ? "ON" : "OFF";
    log("ğŸ” Loop " + (songLoop ? "å·²é–‹å•Ÿ" : "å·²é—œé–‰"), "ok");
  });

  btnRobotSend.addEventListener("click", ()=>{
    sendRobotExplore();
  });

  btnExchange.addEventListener("click", ()=>{
    log("ğŸ¦ äº¤æ˜“æ‰€ï¼šæ­£å¼ç‰ˆå°‡åŠ å…¥ç©å®¶è²·è³£èˆ‡è‚¡ç¥¨ç³»çµ±ï¼ˆå·²é ç•™ï¼‰", "ok");
  });

  btnTech.addEventListener("click", ()=>{
    log("ğŸ§¬ ç§‘æŠ€æ¨¹ï¼šæ­£å¼ç‰ˆåŠ å…¥ç ”ç™¼èˆ‡æ–‡æ˜é€²åŒ–ï¼ˆå·²é ç•™ï¼‰", "ok");
  });

  document.querySelectorAll(".prioBtn").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const p = btn.getAttribute("data-prio");
      state.buildPriority = p;
      prioNow.textContent = "â­ " + BUILDINGS[p].name;
      assistantSay("å„ªå…ˆé †åºå·²æ”¹ç‚ºï¼š" + BUILDINGS[p].name);
    });
  });

  closeChat.addEventListener("click", ()=>{
    assistantChat.style.display = "none";
  });

  sendAssistant.addEventListener("click", ()=>{
    handleAssistantCommand(assistantInput.value);
    assistantInput.value = "";
  });

  assistantInput.addEventListener("keydown", (e)=>{
    if (e.key === "Enter") {
      handleAssistantCommand(assistantInput.value);
      assistantInput.value = "";
    }
  });

  // ==========================================================
  // DRAW WORLD
  // ==========================================================
  function drawBackground() {
    // stars
    for (let i=0;i<40;i++) {
      const x = (i*97 + 33) % W;
      const y = (i*131 + 77) % H;
      ctx.globalAlpha = 0.15;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  function drawWorldObjects() {
    const w = state.world;

    // rivers
    ctx.lineWidth = 10 * state.camera.zoom;
    ctx.strokeStyle = "rgba(80,160,255,0.22)";
    for (const r of w.rivers) {
      ctx.beginPath();
      ctx.moveTo(r.x1, r.y1);
      ctx.quadraticCurveTo((r.x1+r.x2)/2 + 60, (r.y1+r.y2)/2 - 40, r.x2, r.y2);
      ctx.stroke();
    }

    // mountains
    for (const m of w.mountains) {
      ctx.fillStyle = "rgba(130,130,160,0.18)";
      ctx.beginPath();
      ctx.arc(m.x, m.y, m.r, 0, Math.PI*2);
      ctx.fill();
    }

    // forests
    for (const f of w.forests) {
      ctx.fillStyle = "rgba(80,200,120,0.18)";
      ctx.beginPath();
      ctx.arc(f.x, f.y, f.r, 0, Math.PI*2);
      ctx.fill();

      // little trees
      ctx.fillStyle = "rgba(80,200,120,0.4)";
      for (let i=0;i<3;i++) {
        ctx.beginPath();
        ctx.arc(f.x + rand(-f.r*0.4, f.r*0.4), f.y + rand(-f.r*0.4, f.r*0.4), 6, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // rocks
    for (const r of w.rocks) {
      ctx.fillStyle = "rgba(200,200,200,0.15)";
      ctx.beginPath();
      ctx.arc(r.x, r.y, r.r, 0, Math.PI*2);
      ctx.fill();
    }

    // iron nodes
    for (const ir of w.irons) {
      ctx.fillStyle = "rgba(180,180,255,0.18)";
      ctx.beginPath();
      ctx.arc(ir.x, ir.y, ir.r, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function drawTerritory() {
    // territory shadow
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.fillRect(-5000, -5000, 10000, 10000);

    // clear territory circle
    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath();
    ctx.arc(0, 0, state.territoryRadius, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // border
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(0, 0, state.territoryRadius, 0, Math.PI*2);
    ctx.stroke();
  }

  function drawBuilding(b) {
    const p = { x: b.x, y: b.y };
    const size = 22 + b.level * 3;

    // base
    ctx.fillStyle = "rgba(255,255,255,0.12)";
    ctx.beginPath();
    ctx.arc(p.x, p.y+10, size*0.9, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = "rgba(255,255,255,0.22)";
    drawRoundedRect(ctx, p.x-size, p.y-size, size*2, size*1.6, 10);
    ctx.fill();

    // roof
    ctx.fillStyle = "rgba(255,120,120,0.35)";
    ctx.beginPath();
    ctx.moveTo(p.x-size, p.y-size+5);
    ctx.lineTo(p.x, p.y-size-18);
    ctx.lineTo(p.x+size, p.y-size+5);
    ctx.closePath();
    ctx.fill();

    // icon
    ctx.fillStyle = "rgba(255,255,255,0.85)";
    ctx.font = "12px Arial";
    let icon = "ğŸ ";
    if (b.type==="lumber") icon="ğŸªµ";
    if (b.type==="mine") icon="â›ï¸";
    if (b.type==="farm") icon="ğŸŒ¾";
    if (b.type==="factory") icon="ğŸ­";
    if (b.type==="market") icon="ğŸª";
    ctx.fillText(icon, p.x-7, p.y+5);

    // level tag
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    drawRoundedRect(ctx, p.x-16, p.y+size*0.9, 32, 16, 8);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = "10px Arial";
    ctx.fillText("Lv"+b.level, p.x-14, p.y+size*0.9+12);
  }

  function drawWorker(w) {
    // cartoon worker
    ctx.fillStyle = "rgba(255,220,160,0.9)";
    ctx.beginPath();
    ctx.arc(w.x, w.y-10, 8, 0, Math.PI*2);
    ctx.fill();

    // body
    ctx.fillStyle = "rgba(120,180,255,0.85)";
    drawRoundedRect(ctx, w.x-6, w.y-2, 12, 18, 6);
    ctx.fill();

    // legs
    ctx.strokeStyle = "rgba(255,255,255,0.6)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(w.x-3, w.y+16);
    ctx.lineTo(w.x-5, w.y+24);
    ctx.moveTo(w.x+3, w.y+16);
    ctx.lineTo(w.x+5, w.y+24);
    ctx.stroke();
  }

  function drawAnimal(a) {
    // small creature
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.beginPath();
    ctx.arc(a.x, a.y, 6, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,180,200,0.6)";
    ctx.beginPath();
    ctx.arc(a.x-4, a.y-4, 3, 0, Math.PI*2);
    ctx.arc(a.x+4, a.y-4, 3, 0, Math.PI*2);
    ctx.fill();
  }

  function drawBeast(b) {
    ctx.fillStyle = "rgba(255,120,120,0.55)";
    ctx.beginPath();
    ctx.arc(b.x, b.y, 12, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.arc(b.x-4, b.y-3, 2, 0, Math.PI*2);
    ctx.arc(b.x+4, b.y-3, 2, 0, Math.PI*2);
    ctx.fill();
  }

  function drawAssistant() {
    const a = state.assistant;

    // body
    ctx.fillStyle = "rgba(255,220,140,0.92)";
    ctx.beginPath();
    ctx.ellipse(a.x, a.y+10, 14, 16, 0, 0, Math.PI*2);
    ctx.fill();

    // head
    ctx.fillStyle = "rgba(255,230,160,0.98)";
    ctx.beginPath();
    ctx.arc(a.x, a.y-10, 14, 0, Math.PI*2);
    ctx.fill();

    // ears
    ctx.fillStyle = "rgba(255,200,120,0.95)";
    ctx.beginPath();
    ctx.arc(a.x-10, a.y-22, 5, 0, Math.PI*2);
    ctx.arc(a.x+10, a.y-22, 5, 0, Math.PI*2);
    ctx.fill();

    // eyes
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.beginPath();
    ctx.arc(a.x-5, a.y-12, 2, 0, Math.PI*2);
    ctx.arc(a.x+5, a.y-12, 2, 0, Math.PI*2);
    ctx.fill();

    // ad flag slot on head
    ctx.strokeStyle = "rgba(255,255,255,0.7)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(a.x+12, a.y-30);
    ctx.lineTo(a.x+12, a.y-48);
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,0.15)";
    drawRoundedRect(ctx, a.x+12, a.y-48, 28, 14, 6);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.7)";
    ctx.font = "10px Arial";
    ctx.fillText("AD", a.x+19, a.y-37);

    // name
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    drawRoundedRect(ctx, a.x-26, a.y+28, 52, 16, 8);
    ctx.fill();
    ctx.fillStyle = "#fff";
    ctx.font = "10px Arial";
    ctx.fillText("AENO AI", a.x-22, a.y+40);
  }

  // ==========================================================
  // LIFE MOVEMENT
  // ==========================================================
  function moveUnits(dt) {
    // animals roam
    for (const a of state.animals) {
      a.t += dt;
      if (a.t > 2.5) {
        a.vx = rand(-0.4,0.4);
        a.vy = rand(-0.4,0.4);
        a.t = 0;
      }
      a.x += a.vx * 30 * dt;
      a.y += a.vy * 30 * dt;
    }

    // beasts roam outside territory
    for (const b of state.beasts) {
      b.x += b.vx * 25 * dt;
      b.y += b.vy * 25 * dt;
      if (Math.random() < dt*0.3) {
        b.vx = rand(-0.35,0.35);
        b.vy = rand(-0.35,0.35);
      }
    }

    // workers wander within territory
    for (const w of state.workersUnits) {
      const dx = w.tx - w.x;
      const dy = w.ty - w.y;
      const dist = Math.sqrt(dx*dx+dy*dy);

      if (dist < 10 || !isInsideTerritory(w.tx, w.ty)) {
        w.tx = irand(-state.territoryRadius+30, state.territoryRadius-30);
        w.ty = irand(-state.territoryRadius+30, state.territoryRadius-30);
      } else {
        w.x += (dx/dist) * 28 * dt;
        w.y += (dy/dist) * 28 * dt;
      }
    }

    // assistant follow center
    const ax = state.assistant.x;
    const ay = state.assistant.y;
    const tx = Math.sin(nowMs()/1200)*50;
    const ty = Math.cos(nowMs()/1400)*50 - 60;

    state.assistant.x = ax + (tx-ax)*dt*1.2;
    state.assistant.y = ay + (ty-ay)*dt*1.2;
  }

  // ==========================================================
  // OFFLINE SIMULATION
  // ==========================================================
  function simulateOffline() {
    const now = nowMs();
    const last = state.lastTickAt || now;
    let diff = now - last;

    if (diff <= 2000) return;

    if (diff > OFFLINE_CAP_MS) {
      diff = OFFLINE_CAP_MS;
      state.offlineStop = true;
      log("â¸ï¸ é›¢ç·šè¶…é24å°æ™‚ï¼Œå¤–æ›å·²åœæ­¢ï¼ˆéœ€é‡æ–°å•Ÿå‹•ï¼‰", "danger");
    } else {
      state.offlineStop = false;
      log("ğŸ•’ é›¢ç·šè£œç®—ï¼š" + Math.floor(diff/1000) + " ç§’", "ok");
    }

    const sec = diff / 1000;
    tickEconomy(sec);

    state.lastTickAt = now;
  }

  // ==========================================================
  // RENDER LOOP
  // ==========================================================
  let lastFrame = nowMs();

  function render() {
    try {
      const t = nowMs();
      const dt = clamp((t - lastFrame) / 1000, 0, 0.05);
      lastFrame = t;

      // update
      tickEconomy(dt);
      moveUnits(dt);
      autoBuildTick();

      // update HUD
      elPlanetName.textContent = state.planet;
      elGameYear.textContent = Math.floor(state.year).toLocaleString();
      elPopCount.textContent = state.population;
      elCoins.textContent = state.coins.toLocaleString();
      elAeno.textContent = state.aeno.toFixed(4);

      elWood.textContent = state.wood.toLocaleString();
      elStone.textContent = state.stone.toLocaleString();
      elIron.textContent = state.iron.toLocaleString();
      elFood.textContent = Math.floor(state.food).toLocaleString();

      elFactoryCount.textContent = state.buildings.filter(b=>b.type==="factory").length;
      elRobotCount.textContent = state.robots;

      autoState.textContent = state.autoBuild ? "ON" : "OFF";
      loopState.textContent = songLoop ? "ON" : "OFF";

      // camera transform
      ctx.clearRect(0,0,W,H);
      drawBackground();

      ctx.save();
      ctx.translate(W/2, H/2);
      ctx.scale(state.camera.zoom, state.camera.zoom);
      ctx.translate(-state.camera.x, -state.camera.y);

      // world
      drawWorldObjects();
      drawTerritory();

      // buildings
      for (const b of state.buildings) drawBuilding(b);

      // animals
      for (const a of state.animals) drawAnimal(a);

      // beasts
      // only show beasts when territory level >= 3 (as you required 100% city ready later)
      if (state.territoryLevel >= 3) {
        for (const b of state.beasts) drawBeast(b);
      }

      // workers
      for (const w of state.workersUnits) drawWorker(w);

      // assistant
      drawAssistant();

      ctx.restore();

      // autosave every 20s
      if (!state._lastAutoSave) state._lastAutoSave = t;
      if (t - state._lastAutoSave > 20000) {
        safeSave();
        state._lastAutoSave = t;
      }

    } catch(e) {
      // never crash loop
      console.error(e);
    }

    requestAnimationFrame(render);
  }

  // ==========================================================
  // GAME START
  // ==========================================================
  window.startGame = function(planetName, seedType) {
    document.getElementById("planetSelect").style.display = "none";

    let loaded = safeLoad();
    if (!loaded) {
      state = defaultState();
      state.planet = planetName;
      state.seedType = seedType;
      log("ğŸŒŸ æ–°éŠæˆ²é–‹å§‹ï¼å·²çµ¦ä½ åˆå§‹è³‡æº + æˆ¿å±‹ + å·¥äºº", "ok");
    } else {
      state = loaded;
      // ensure new keys exist after updates
      deepMerge(state, defaultState());
      state.planet = planetName; // allow switching planet but keep save structure
      state.seedType = seedType;
      log("ğŸ“¦ å·²è®€å–ä¿å­˜é€²åº¦ï¼ˆç‰ˆæœ¬æ›´æ–°ä¸æœƒé‡ç½®ï¼‰", "ok");
    }

    ensureWorldGenerated();
    spawnLife();

    // offline sim
    simulateOffline();

    // show assistant greeting
    assistantSay("ä½ å¥½ä¸»äººï¼é»æˆ‘å¯ä»¥é–‹å•Ÿå°è©±ã€‚");
    assistantSay("é»é ˜åœŸç©ºåœ°å¯ä»¥å»ºç¯‰ï¼Œé»å»ºç¯‰å¯æŸ¥çœ‹ã€‚");
    assistantSay("ä½ å¯ä»¥è¼¸å…¥ï¼šåœæ­¢ / å»ºé€  / å‡ç´š / å·¡é‚ / æ”¶é›†");

    // set default panel position
    panel.style.display = "flex";
    panel.style.left = "auto";
    panel.style.top = "auto";
    panel.style.right = "8px";
    panel.style.bottom = "80px";

    // initial camera
    state.camera.x = 0;
    state.camera.y = 0;
    state.camera.zoom = 1.1;

    // if black hole island: make territory special
    if (planetName === "BlackHole-Island") {
      state.territoryRadius = Math.max(state.territoryRadius, 180);
      log("ğŸ•³ï¸ ä½ å·²é€²å…¥é»‘æ´å­¤å³¶ï¼ˆDeveloper Islandï¼‰", "ok");
    }

    safeSave();
    render();
  };

})();
</script>

</body>
</html>
